"""
–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º SpeechRecognition
"""

import asyncio
import logging
import time
import threading
from typing import Optional, Callable, Dict, Any, List
import sounddevice as sd
import numpy as np
import speech_recognition as sr

from .types import (
    RecognitionConfig, RecognitionResult, RecognitionState, 
    RecognitionEventType, RecognitionMetrics
)

logger = logging.getLogger(__name__)

class SpeechRecognizer:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏"""
    
    def __init__(self, config: RecognitionConfig):
        self.config = config
        self.state = RecognitionState.IDLE
        
        # –ê—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ
        self.audio_data = []
        self.is_listening = False
        self.listen_start_time = None
        
        # Threading
        self.listen_thread = None
        self.stop_event = threading.Event()
        self.audio_lock = threading.Lock()
        
        # Callbacks
        self.state_callbacks: Dict[RecognitionState, Callable] = {}
        self.event_callbacks: Dict[RecognitionEventType, Callable] = {}
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        self.metrics = RecognitionMetrics()

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ö–æ–¥–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        self.input_device_index: Optional[int] = None
        self.actual_input_rate: int = self.config.sample_rate
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å
        self._init_recognizer()
        
    def _init_recognizer(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å —Ä–µ—á–∏"""
        try:
            self.recognizer = sr.Recognizer()
            self.microphone = sr.Microphone()
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            self.recognizer.energy_threshold = self.config.energy_threshold
            self.recognizer.dynamic_energy_threshold = self.config.dynamic_energy_threshold
            self.recognizer.pause_threshold = self.config.pause_threshold
            self.recognizer.phrase_threshold = self.config.phrase_threshold
            self.recognizer.non_speaking_duration = self.config.non_speaking_duration
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞ (–ë–ï–ó –ë–õ–û–ö–ò–†–û–í–ö–ò)
            try:
                with self.microphone as source:
                    logger.info("üîß –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞...")
                    self.recognizer.adjust_for_ambient_noise(source, duration=1)
                    logger.info(f"üìä –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –ø–æ—Ä–æ–≥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {self.recognizer.energy_threshold}")
            except Exception as mic_error:
                # –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é): {mic_error}")
                self.recognizer.energy_threshold = 300  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            
            logger.info(f"‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å —Ä–µ—á–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (—è–∑—ã–∫: {self.config.language})")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—è (–ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É): {e}")
            # –ù–ï —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ERROR - –ø–æ–∑–≤–æ–ª—è–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å –≤ degraded —Ä–µ–∂–∏–º–µ
            self.state = RecognitionState.IDLE
            
    def _pick_input_device(self) -> Optional[int]:
        """–ü–æ–¥–±–∏—Ä–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ–µ –≤—Ö–æ–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ. –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ: –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –º–∏–∫—Ä–æ—Ñ–æ–Ω."""
        try:
            devices = sd.query_devices()
            input_devices = [
                (idx, dev)
                for idx, dev in enumerate(devices)
                if dev.get('max_input_channels', 0) > 0
            ]
            logger.debug(
                "üéõÔ∏è –î–æ—Å—Ç—É–ø–Ω—ã–µ –≤—Ö–æ–¥–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: %s",
                [
                    {
                        "index": idx,
                        "name": dev.get("name"),
                        "default_rate": dev.get("default_samplerate"),
                        "channels": dev.get("max_input_channels"),
                    }
                    for idx, dev in input_devices
                ],
            )
            # –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –Ω–∞ macOS
            builtin_keywords = [
                'built-in microphone', 'macbook', 'internal microphone',
                'microphone (built-in)', 'default - built-in'
            ]
            # –ò—â–µ–º –ø–æ –∏–º–µ–Ω–∏
            for i, d in enumerate(devices):
                name = str(d.get('name', '')).lower()
                if d.get('max_input_channels', 0) > 0 and any(k in name for k in builtin_keywords):
                    logger.info("üéöÔ∏è –í—ã–±—Ä–∞–Ω –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –º–∏–∫—Ä–æ—Ñ–æ–Ω: %s (index=%s)", d.get('name'), i)
                    return i
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî –±–µ—Ä–µ–º –¥–µ–≤–∞–π—Å —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º —á–∏—Å–ª–æ–º –≤—Ö–æ–¥–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤, –∏–∑–±–µ–≥–∞—è bluetooth-headset
            candidates = []
            for i, d in enumerate(devices):
                ch = d.get('max_input_channels', 0)
                if ch > 0:
                    name = str(d.get('name', '')).lower()
                    is_bt_headset = ('airpods' in name) or ('headset' in name) or ('hands-free' in name)
                    candidates.append((i, ch, 0 if is_bt_headset else 1))
            if candidates:
                # –°–æ—Ä—Ç–∏—Ä—É–µ–º: non-bt –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–µ–µ, –∑–∞—Ç–µ–º –ø–æ –∫–∞–Ω–∞–ª–∞–º
                candidates.sort(key=lambda x: (x[2], x[1]), reverse=True)
                selected = candidates[0][0]
                dev = devices[selected]
                logger.info(
                    "üéöÔ∏è –í—ã–±—Ä–∞–Ω–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: %s (index=%s, channels=%s)",
                    dev.get('name'),
                    selected,
                    dev.get('max_input_channels'),
                )
                return selected
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Ö–æ–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {e}")
        return None

    async def start_listening(self) -> bool:
        """–ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞"""
        try:
            if self.state != RecognitionState.IDLE:
                logger.warning(f"‚ö†Ô∏è –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞—á–∞—Ç—å –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ {self.state.value}")
                return False
                
            self.state = RecognitionState.LISTENING
            self.is_listening = True
            self.audio_data = []
            self.stop_event.clear()
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –æ –Ω–∞—á–∞–ª–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
            await self._notify_state_change(RecognitionState.LISTENING)
            await self._notify_event(RecognitionEventType.LISTENING_START)
            logger.debug(
                "üé§ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: target_rate=%sHz, channels=%s, chunk=%s, dtype=%s",
                self.config.sample_rate,
                self.config.channels,
                self.config.chunk_size,
                self.config.dtype,
            )
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
            self.listen_thread = threading.Thread(
                target=self._run_listening,
                name="SpeechListening",
                daemon=True
            )
            self.listen_thread.start()
            
            logger.info("üé§ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –Ω–∞—á–∞—Ç–æ")
            return True
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –Ω–∞—á–∞–ª–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è (–ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É): {e}")
            # –ù–ï —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ERROR - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ IDLE –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
            self.state = RecognitionState.IDLE
            await self._notify_state_change(RecognitionState.IDLE, error=str(e))
            return False
            
    async def stop_listening(self) -> RecognitionResult:
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è"""
        try:
            if self.state != RecognitionState.LISTENING:
                logger.warning(f"‚ö†Ô∏è –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ {self.state.value}")
                return RecognitionResult(text="", error="Not listening")
                
            self.state = RecognitionState.PROCESSING
            self.is_listening = False
            self.stop_event.set()
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
            await self._notify_event(RecognitionEventType.LISTENING_STOP)
            await self._notify_state_change(RecognitionState.PROCESSING)
            
            # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
            if self.listen_thread and self.listen_thread.is_alive():
                logger.debug("‚è≥ –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞ –∑–∞–ø–∏—Å–∏...")
                self.listen_thread.join(timeout=5.0)
            
            # –†–∞—Å–ø–æ–∑–Ω–∞–µ–º —Ä–µ—á—å
            logger.debug(
                "üéß –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–ø–∏—Å—å: chunks=%s, thread_alive=%s",
                len(self.audio_data),
                self.listen_thread.is_alive() if self.listen_thread else False,
            )
            result = await self._recognize_audio()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
            self._update_metrics(result)
            
            self.state = RecognitionState.IDLE
            await self._notify_state_change(RecognitionState.IDLE)
            
            if result.text:
                logger.info(f"üìù –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {result.text}")
            else:
                logger.warning("‚ö†Ô∏è –†–µ—á—å –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞")
                
            return result
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}")
            self.state = RecognitionState.ERROR
            await self._notify_state_change(RecognitionState.ERROR, error=str(e))
            return RecognitionResult(text="", error=str(e))
            
    def _run_listening(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞"""
        try:
            # –ü–æ–¥–±–∏—Ä–∞–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            self.input_device_index = self._pick_input_device()
            logger.info(
                "üéõÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤–≤–æ–¥–∞: index=%s",
                self.input_device_index if self.input_device_index is not None else "default",
            )
            device_param = self.input_device_index if self.input_device_index is not None else None
            # –ü—Ä–æ–±—É–µ–º —Å –∂–µ–ª–∞–µ–º–æ–π —á–∞—Å—Ç–æ—Ç–æ–π
            try:
                self.actual_input_rate = self.config.sample_rate
                stream = sd.InputStream(
                    device=device_param,
                    samplerate=self.config.sample_rate,
                    channels=self.config.channels,
                    dtype=self.config.dtype,
                    blocksize=self.config.chunk_size,
                    callback=self._audio_callback
                )
                stream.start()
            except Exception as e1:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å InputStream —Å {self.config.sample_rate} Hz: {e1}")
                # –ü—Ä–æ–±—É–µ–º —Å –¥–µ—Ñ–æ–ª—Ç–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                try:
                    if device_param is not None:
                        dev_info = sd.query_devices(device_param)
                    else:
                        dev_info = sd.query_devices(None, 'input')
                    fallback_rate = int(dev_info.get('default_samplerate') or 16000)
                    self.actual_input_rate = fallback_rate
                    logger.info(
                        "üîÅ –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ fallback —á–∞—Å—Ç–æ—Ç—É: %s Hz (device default)",
                        fallback_rate,
                    )
                    stream = sd.InputStream(
                        device=device_param,
                        samplerate=fallback_rate,
                        channels=self.config.channels,
                        dtype=self.config.dtype,
                        blocksize=self.config.chunk_size,
                        callback=self._audio_callback
                    )
                    stream.start()
                except Exception as e2:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è InputStream –¥–∞–∂–µ —Å –¥–µ—Ñ–æ–ª—Ç–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π: {e2}")
                    self.state = RecognitionState.ERROR
                    return

            with stream:
                self.listen_start_time = time.time()
                logger.debug("‚è±Ô∏è –ü–æ—Ç–æ–∫ –∑–∞–ø–∏—Å–∏ –∑–∞–ø—É—â–µ–Ω (actual_rate=%s)", self.actual_input_rate)
                
                while self.is_listening and not self.stop_event.is_set():
                    time.sleep(0.1)
                
                duration = time.time() - self.listen_start_time if self.listen_start_time else 0
                logger.debug("üõë –ü–æ—Ç–æ–∫ –∑–∞–ø–∏—Å–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å=%.2fs", duration)
                    
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: {e}")
            self.state = RecognitionState.ERROR
            
    def _audio_callback(self, indata, frames, time, status):
        """Callback –¥–ª—è –∑–∞–ø–∏—Å–∏ –∞—É–¥–∏–æ"""
        try:
            if status:
                logger.warning(f"‚ö†Ô∏è –°—Ç–∞—Ç—É—Å –∞—É–¥–∏–æ: {status}")
                
            if self.is_listening:
                with self.audio_lock:
                    self.audio_data.append(indata.copy())
                    if len(self.audio_data) == 1:
                        logger.debug(
                            "üîä –ü–µ—Ä–≤—ã–π —á–∞–Ω–∫ –ø–æ–ª—É—á–µ–Ω: frames=%s, dtype=%s",
                            frames,
                            indata.dtype,
                        )
                    
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ audio callback: {e}")
            
    async def _recognize_audio(self) -> RecognitionResult:
        """–†–∞—Å–ø–æ–∑–Ω–∞–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–µ –∞—É–¥–∏–æ"""
        try:
            if not self.audio_data:
                logger.warning("‚ö†Ô∏è –ù–µ—Ç –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è")
                return RecognitionResult(text="", error="No audio data")
                
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –∞—É–¥–∏–æ —á–∞–Ω–∫–∏
            with self.audio_lock:
                audio_data = np.concatenate(self.audio_data, axis=0)
            sample_count = audio_data.shape[0]
            duration_sec = sample_count / float(self.actual_input_rate or self.config.sample_rate)
            peak = float(np.max(np.abs(audio_data)))
            rms = float(np.sqrt(np.mean(audio_data.astype(np.float64) ** 2)))
            logger.info(
                "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞—É–¥–∏–æ: chunks=%s, samples=%s, duration=%.2fs, peak=%.0f, rms=%.1f, actual_rate=%s, target_rate=%s",
                len(self.audio_data),
                sample_count,
                duration_sec,
                peak,
                rms,
                self.actual_input_rate,
                self.config.sample_rate,
            )
                
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
            if self.config.channels > 1:
                audio_data = np.mean(audio_data, axis=1)
                
            # –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å –≤–µ–ª–∞—Å—å –Ω–µ –Ω–∞ —Ç–æ–π —á–∞—Å—Ç–æ—Ç–µ, –ø—Ä–∏–≤–æ–¥–∏–º –∫ —Ü–µ–ª–µ–≤–æ–π
            try:
                if self.actual_input_rate != self.config.sample_rate:
                    from modules.voice_recognition.utils.audio_utils import resample_audio
                    logger.debug(
                        "üîÑ –í—ã–ø–æ–ª–Ω—è–µ–º —Ä–µ—Å–µ–º–ø–ª–∏–Ω–≥: %s ‚Üí %s",
                        self.actual_input_rate,
                        self.config.sample_rate,
                    )
                    audio_data = resample_audio(audio_data, self.actual_input_rate, self.config.sample_rate)
            except Exception as re:
                logger.debug(f"Resample skipped: {re}")

            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∞—É–¥–∏–æ
            audio_data = audio_data.astype(np.float32) / np.iinfo(np.int16).max
            
            # –°–æ–∑–¥–∞–µ–º AudioData –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
            audio_bytes = (audio_data * 32767).astype(np.int16).tobytes()
            audio_data_obj = sr.AudioData(audio_bytes, self.config.sample_rate, 2)
            
            # –†–∞—Å–ø–æ–∑–Ω–∞–µ–º —Ä–µ—á—å
            start_time = time.time()
            await self._notify_event(RecognitionEventType.RECOGNITION_START)
            
            try:
                text = await self._recognize_with_engine(audio_data_obj)
                duration = time.time() - start_time
                
                result = RecognitionResult(
                    text=text,
                    confidence=None,  # SpeechRecognition –Ω–µ –≤—Å–µ–≥–¥–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç confidence
                    language=self.config.language,
                    duration=duration,
                    timestamp=time.time()
                )
                
                await self._notify_event(RecognitionEventType.RECOGNITION_COMPLETE, result=result)
                logger.info(
                    "‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: text_length=%s, duration=%.2fs, language=%s",
                    len(text),
                    duration,
                    self.config.language,
                )
                return result
                
            except sr.UnknownValueError:
                logger.warning(
                    "‚ö†Ô∏è Google Speech Recognition –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª –∞—É–¥–∏–æ (duration=%.2fs, rms=%.1f, peak=%.0f)",
                    duration_sec,
                    rms,
                    peak,
                )
                return RecognitionResult(text="", error="Speech not recognized")
            except sr.RequestError as e:
                logger.error(
                    "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è (language=%s, duration=%.2fs): %s",
                    self.config.language,
                    duration_sec,
                    e,
                )
                return RecognitionResult(text="", error=str(e))
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –∞—É–¥–∏–æ: {e}", exc_info=True)
            return RecognitionResult(text="", error=str(e))
            
    async def _recognize_with_engine(self, audio_data: sr.AudioData) -> str:
        """–†–∞—Å–ø–æ–∑–Ω–∞–µ—Ç –∞—É–¥–∏–æ —Å –ø–æ–º–æ—â—å—é Google Speech Recognition"""
        try:
            return self.recognizer.recognize_google(audio_data, language=self.config.language)
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Å Google Speech Recognition: {e}")
            raise
            
    def _update_metrics(self, result: RecognitionResult):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è"""
        self.metrics.total_recognitions += 1
        
        if result.text and not result.error:
            self.metrics.successful_recognitions += 1
            self.metrics.recognitions_by_language[result.language] = (
                self.metrics.recognitions_by_language.get(result.language, 0) + 1
            )
            
            if result.confidence:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω—é—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
                if self.metrics.successful_recognitions > 0:
                    self.metrics.average_confidence = (
                        (self.metrics.average_confidence * (self.metrics.successful_recognitions - 1) + result.confidence) 
                        / self.metrics.successful_recognitions
                    )
        else:
            self.metrics.failed_recognitions += 1
            
                
    def register_callback(self, state: RecognitionState, callback: Callable):
        """–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç callback –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        self.state_callbacks[state] = callback
        logger.debug(f"üìù –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω callback –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è {state.value}")
        
    def register_event_callback(self, event_type: RecognitionEventType, callback: Callable):
        """–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç callback –¥–ª—è —Å–æ–±—ã—Ç–∏—è"""
        self.event_callbacks[event_type] = callback
        logger.debug(f"üìù –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω callback –¥–ª—è —Å–æ–±—ã—Ç–∏—è {event_type.value}")
        
    async def _notify_state_change(self, state: RecognitionState, **kwargs):
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        try:
            callback = self.state_callbacks.get(state)
            if callback:
                from .types import RecognitionEvent
                event = RecognitionEvent(
                    event_type=RecognitionEventType.LISTENING_START,  # –ë–∞–∑–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ
                    state=state,
                    timestamp=time.time(),
                    **kwargs
                )
                await callback(event)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–º–µ–Ω–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
            
    async def _notify_event(self, event_type: RecognitionEventType, **kwargs):
        """–£–≤–µ–¥–æ–º–ª—è–µ—Ç –æ —Å–æ–±—ã—Ç–∏–∏"""
        try:
            callback = self.event_callbacks.get(event_type)
            if callback:
                from .types import RecognitionEvent
                event = RecognitionEvent(
                    event_type=event_type,
                    state=self.state,
                    timestamp=time.time(),
                    **kwargs
                )
                await callback(event)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–æ–±—ã—Ç–∏–∏: {e}")
            
    def get_status(self) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏"""
        return {
            "state": self.state.value,
            "is_listening": self.is_listening,
            "audio_data_chunks": len(self.audio_data),
            "config": {
                "language": self.config.language,
                "sample_rate": self.config.sample_rate,
                "chunk_size": self.config.chunk_size,
                "channels": self.config.channels,
            },
            "metrics": {
                "total_recognitions": self.metrics.total_recognitions,
                "successful_recognitions": self.metrics.successful_recognitions,
                "failed_recognitions": self.metrics.failed_recognitions,
                "success_rate": (
                    self.metrics.successful_recognitions / max(self.metrics.total_recognitions, 1) * 100
                ),
                "average_confidence": self.metrics.average_confidence,
                "average_duration": self.metrics.average_duration,
            },
            "callbacks_registered": len(self.state_callbacks) + len(self.event_callbacks)
        }
        
    def get_metrics(self) -> RecognitionMetrics:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è"""
        return self.metrics
