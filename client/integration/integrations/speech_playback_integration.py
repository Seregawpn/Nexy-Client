"""
SpeechPlaybackIntegration ‚Äî –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —Å EventBus

–°–ª—É—à–∞–µ—Ç gRPC-–æ—Ç–≤–µ—Ç—ã (`grpc.response.audio`, `grpc.request_completed|failed`) –∏ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç –∞—É–¥–∏–æ-—á–∞–Ω–∫–∏.
–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ—Ç–º–µ–Ω—É —á–µ—Ä–µ–∑ `keyboard.short_press`/`interrupt.request`.
"""

import asyncio
import logging
from dataclasses import dataclass
from typing import Optional, Dict, Any

import numpy as np

from integration.core.event_bus import EventBus, EventPriority
from integration.core.state_manager import ApplicationStateManager, AppMode
from integration.core.error_handler import ErrorHandler

from modules.speech_playback.core.player import SequentialSpeechPlayer, PlayerConfig
from modules.speech_playback.core.state import PlaybackState

# –¶–ï–ù–¢–†–ê–õ–ò–ó–û–í–ê–ù–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ê–£–î–ò–û
from config.unified_config_loader import unified_config

logger = logging.getLogger(__name__)


class SpeechPlaybackIntegration:
    """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è SequentialSpeechPlayer —Å EventBus"""

    def __init__(
        self,
        event_bus: EventBus,
        state_manager: ApplicationStateManager,
        error_handler: ErrorHandler,
    ):
        self.event_bus = event_bus
        self.state_manager = state_manager
        self.error_handler = error_handler
        
        # –¶–ï–ù–¢–†–ê–õ–ò–ó–û–í–ê–ù–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø - –µ–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã
        self.config = unified_config.get_speech_playback_config()

        self._player: Optional[SequentialSpeechPlayer] = None
        self._initialized = False
        self._running = False
        self._had_audio_for_session: Dict[Any, bool] = {}
        self._finalized_sessions: Dict[Any, bool] = {}
        self._last_audio_ts: float = 0.0
        self._silence_task: Optional[asyncio.Task] = None
        # –ü–æ–º–µ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–º —Å–µ—Å—Å–∏–π (–ø–æ–ª—É—á–µ–Ω grpc.request_completed/failed)
        self._grpc_done_sessions: Dict[Any, bool] = {}
        # –¢–µ–∫—É—â–∞—è –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è (–ø–æ—Å–ª–µ–¥–Ω—è—è)
        self._current_session_id: Optional[Any] = None
        # –ü–æ–º–µ—Ç–∫–∏ –æ—Ç–º–µ–Ω—ë–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–∑–¥–Ω–∏—Ö —á–∞–Ω–∫–æ–≤
        self._cancelled_sessions: set = set()

    async def initialize(self) -> bool:
        try:
            # –õ–µ–Ω–∏–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–µ–µ—Ä–∞ —Å —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
            pc = PlayerConfig(
                sample_rate=self.config['sample_rate'],
                channels=self.config['channels'],
                dtype=self.config['dtype'],
                buffer_size=self.config['buffer_size'],
                max_memory_mb=self.config['max_memory_mb'],
                auto_device_selection=self.config['auto_device_selection'],
            )
            self._player = SequentialSpeechPlayer(pc)
            # –ö–æ–ª–ª–±–µ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è ‚Äî —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤ EventBus
            try:
                self._player.set_callbacks(on_playback_completed=self._on_player_completed)
            except Exception:
                pass

            # –ü–æ–¥–ø–∏—Å–∫–∏
            await self.event_bus.subscribe("grpc.response.audio", self._on_audio_chunk, EventPriority.HIGH)
            await self.event_bus.subscribe("grpc.request_completed", self._on_grpc_completed, EventPriority.HIGH)
            await self.event_bus.subscribe("grpc.request_failed", self._on_grpc_failed, EventPriority.HIGH)
            # –°–∏–≥–Ω–∞–ª—ã (–∫–æ—Ä–æ—Ç–∫–∏–µ —Ç–æ–Ω—ã) —á–µ—Ä–µ–∑ EventBus
            await self.event_bus.subscribe("playback.signal", self._on_playback_signal, EventPriority.HIGH)
            
            # –ï–î–ò–ù–´–ô –∫–∞–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π - —Ç–æ–ª—å–∫–æ playback.cancelled
            await self.event_bus.subscribe("playback.cancelled", self._on_unified_interrupt, EventPriority.CRITICAL)
            
            # –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ –ø—Ä—è–º—ã–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–æ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤ –µ–¥–∏–Ω—ã–π –∫–∞–Ω–∞–ª)
            # –£–ë–†–ê–ù–û: keyboard.short_press - –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤ LISTENING
            # –£–ë–†–ê–ù–û: interrupt.request - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ –≤ InterruptManagementIntegration
            await self.event_bus.subscribe("app.shutdown", self._on_app_shutdown, EventPriority.HIGH)
            # –†–µ–∞–≥–∏—Ä—É–µ–º –Ω–∞ —Å–º–µ–Ω—É –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            try:
                await self.event_bus.subscribe("audio.device_switched", self._on_audio_device_switched, EventPriority.MEDIUM)
            except Exception:
                pass

            self._initialized = True
            logger.info("SpeechPlaybackIntegration initialized")
            return True
        except Exception as e:
            await self._handle_error(e, where="speech.initialize")
            return False

    async def start(self) -> bool:
        if not self._initialized:
            logger.error("SpeechPlaybackIntegration not initialized")
            return False
        self._running = True
        return True

    async def stop(self) -> bool:
        try:
            if self._player:
                try:
                    self._player.stop_playback()
                    self._player.shutdown()
                except Exception:
                    pass
            self._running = False
            return True
        except Exception as e:
            await self._handle_error(e, where="speech.stop", severity="warning")
            return False

    # -------- Event Handlers --------
    async def _on_audio_chunk(self, event):
        try:
            data = (event or {}).get("data", {})
            sid = data.get("session_id")
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ–∑–¥–Ω–∏—Ö —á–∞–Ω–∫–æ–≤ –ø–æ—Å–ª–µ –æ—Ç–º–µ–Ω—ã
            if sid is not None and (sid in self._cancelled_sessions):
                logger.debug(f"Ignoring audio chunk for cancelled sid={sid}")
                return
            if sid is not None:
                self._current_session_id = sid
            audio_bytes: bytes = data.get("bytes") or b""
            dtype: str = (data.get("dtype") or 'int16').lower()
            shape = data.get("shape") or []
            src_sample_rate: Optional[int] = data.get("sample_rate")
            src_channels: Optional[int] = data.get("channels")
            if not audio_bytes:
                return

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–µ–µ—Ä–∞ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —á–∞–Ω–∫–µ
            if self._player and not self._player.state_manager.is_playing and not self._player.state_manager.is_paused:
                if not self._player.initialize():
                    await self._handle_error(Exception("player_init_failed"), where="speech.player_init")
                    return

            # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ numpy + –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞
            try:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º dtype —Å —É—á—ë—Ç–æ–º –≤–æ–∑–º–æ–∂–Ω–æ–π —ç–Ω–¥–ò–∞–Ω–Ω–æ—Å—Ç–∏
                dt: Any
                if dtype in ('float32', 'float'):
                    dt = np.float32
                elif dtype in ('int16_be', 'pcm_s16be'):
                    dt = np.dtype('>i2')
                elif dtype in ('int16_le', 'pcm_s16le'):
                    dt = np.dtype('<i2')
                elif dtype in ('int16', 'short'):
                    # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º little-endian, –Ω–æ –ø—Ä–æ–≤–µ—Ä–∏–º byteswap —ç–≤—Ä–∏—Å—Ç–∏–∫–æ–π
                    dt = np.dtype('<i2')
                else:
                    dt = np.dtype('<i2')

                arr = np.frombuffer(audio_bytes, dtype=dt)
                # –ï—Å–ª–∏ —Ç–∏–ø int16 –±–µ–∑ —è–≤–Ω–æ–π —ç–Ω–¥–ò–∞–Ω–Ω–æ—Å—Ç–∏ ‚Äî —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ byteswap –ø–æ –ø–∏–∫—É —Å–∏–≥–Ω–∞–ª–∞
                try:
                    if dt.kind == 'i' and dt.itemsize == 2 and dtype in ('int16', 'short'):
                        peak = float(np.max(np.abs(arr))) if arr.size else 0.0
                        swapped = arr.byteswap().newbyteorder()
                        peak_sw = float(np.max(np.abs(swapped))) if swapped.size else 0.0
                        if peak_sw > peak * 1.8:
                            arr = swapped
                except Exception:
                    pass
                if shape and len(shape) > 0:
                    try:
                        arr = arr.reshape(shape)
                    except Exception:
                        pass
                # –ü—Ä–∏–≤–æ–¥–∏–º dtype –∫ int16 –ø—Ä–∏ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–∏ float32 (–µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω int16 –≤—ã–≤–æ–¥)
                if arr.dtype == np.float32:
                    scaled = np.clip(arr, -1.0, 1.0) * 32767.0
                    arr = scaled.astype(np.int16)
                # –ï—Å–ª–∏ —É–∂–µ int16 - –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å (—É–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏)
                # –ü—Ä–æ—á–µ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç–∞ (—Ä–µ—Å–µ–º–ø–ª–∏–Ω–≥/–∫–∞–Ω–∞–ª—ã) –≤—ã–ø–æ–ª–Ω—è–µ—Ç –ø–ª–µ–µ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ metadata

                # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –ª–æ–≥–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤—ã —Ñ–æ—Ä–º–∞—Ç–∞ (–±–µ–∑ —Å–ø–∞–º–º–∞)
                try:
                    _min = float(arr.min()) if arr.size else 0.0
                    _max = float(arr.max()) if arr.size else 0.0
                    logger.info(f"üîç audio_chunk: sid={sid}, dtype={arr.dtype}, shape={getattr(arr,'shape',())}, min={_min:.3f}, max={_max:.3f}, bytes={len(audio_bytes)}")
                except Exception:
                    pass
            except Exception as e:
                await self._handle_error(e, where="speech.decode_audio", severity="warning")
                return

            # –î–æ–±–∞–≤–ª—è–µ–º —á–∞–Ω–∫ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º/–≤–æ–∑–æ–±–Ω–æ–≤–ª—è–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
            try:
                if self._player:
                    self._player.add_audio_data(
                        arr,
                        priority=0,
                        metadata={
                            "session_id": sid,
                            "sample_rate": src_sample_rate,
                            "channels": src_channels,
                        },
                    )
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–ª–µ–µ—Ä–∞ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —É–ø—Ä–∞–≤–ª—è–µ–º
                    state = self._player.state_manager.get_state()
                    if state == PlaybackState.PAUSED:
                        # –ï—Å–ª–∏ –ø–∞—É–∑–∞ ‚Äî —Ä–µ–∑—é–º–∏—Ä—É–µ–º
                        self._player.resume_playback()
                    elif state != PlaybackState.PLAYING:
                        # IDLE/ERROR/STOPPING ‚Äî –ø—ã—Ç–∞–µ–º—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                        # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è/–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–∞
                        if not self._player.initialize():
                            await self._handle_error(Exception("player_init_failed"), where="speech.player_init")
                            return
                        if not self._player.start_playback():
                            await self._handle_error(Exception("start_failed"), where="speech.start_playback")
                            return
                        await self.event_bus.publish("playback.started", {"session_id": sid})
                self._had_audio_for_session[sid] = True

                # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∞—É–¥–∏–æ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä —Ç–∏—à–∏–Ω—ã
                try:
                    self._last_audio_ts = asyncio.get_event_loop().time()
                    if self._silence_task and not self._silence_task.done():
                        self._silence_task.cancel()
                    self._silence_task = asyncio.create_task(self._finalize_on_silence(sid, timeout=1.0))
                except Exception:
                    pass
            except Exception as e:
                await self._handle_error(e, where="speech.add_chunk")

        except Exception as e:
            await self._handle_error(e, where="speech.on_audio_chunk", severity="warning")

    async def _on_audio_device_switched(self, event):
        """–ú—è–≥–∫–æ–µ –ø–µ—Ä–µ—Å—Ç—Ä–æ–µ–Ω–∏–µ —á–∏—Å–ª–∞ –∫–∞–Ω–∞–ª–æ–≤ –ø—Ä–∏ —Å–º–µ–Ω–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –≤—ã–≤–æ–¥–∞"""
        try:
            if not self._player:
                return
            # –û–ø—Ä–∞—à–∏–≤–∞–µ–º –ª—É—á—à–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∏ –µ–≥–æ –∫–∞–Ω–∞–ª—ã
            try:
                from modules.speech_playback.utils.device_utils import get_best_audio_device
                dev = get_best_audio_device()
                if not dev:
                    return
                target_ch = 1 if getattr(dev, 'channels', 1) <= 1 else 2
            except Exception:
                return
            # –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—ã–≤–æ–¥, –µ—Å–ª–∏ —á–∏—Å–ª–æ –∫–∞–Ω–∞–ª–æ–≤ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
            try:
                loop = asyncio.get_running_loop()
                await loop.run_in_executor(None, self._player.reconfigure_channels, target_ch)
            except Exception:
                pass
        except Exception as e:
            await self._handle_error(e, where="speech.on_device_switched", severity="warning")

    async def _on_grpc_completed(self, event):
        try:
            data = (event or {}).get("data", {})
            sid = data.get("session_id")
            if sid is not None:
                self._grpc_done_sessions[sid] = True
            # –î–∞–µ–º –ø–ª–µ–µ—Ä—É –¥–æ–∏–≥—Ä–∞—Ç—å –±—É—Ñ–µ—Ä –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            async def _drain_and_stop():
                try:
                    if self._player:
                        # –æ–∂–∏–¥–∞–µ–º –æ–ø—É—Å—Ç–æ—à–µ–Ω–∏—è –±—É—Ñ–µ—Ä–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
                        loop = asyncio.get_running_loop()
                        await loop.run_in_executor(None, self._player.wait_for_completion)
                        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –¥—Ä–µ–Ω–∞–∂–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –≤—ã–≤–æ–¥–∞
                        try:
                            drain_sec = max(0.05, min(0.25, (self.config['buffer_size'] / self.config['sample_rate']) * 4.0))
                            await asyncio.sleep(drain_sec)
                        except Exception:
                            pass
                        # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ç–æ–∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
                        self._player.stop_playback()
                    await self.event_bus.publish("playback.completed", {"session_id": sid})
                    self._finalized_sessions[sid] = True
                    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤ SLEEPING —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ
                    try:
                        await self.event_bus.publish("mode.request", {
                            "target": AppMode.SLEEPING,
                            "source": "speech_playback"
                        })
                    except Exception:
                        pass
                except Exception as e:
                    await self._handle_error(e, where="speech.drain_stop", severity="warning")
            asyncio.create_task(_drain_and_stop())
        except Exception as e:
            await self._handle_error(e, where="speech.on_grpc_completed", severity="warning")

    async def _on_grpc_failed(self, event):
        try:
            data = (event or {}).get("data", {})
            sid = data.get("session_id")
            err = (data.get("error") or "").lower()
            if sid is not None:
                self._grpc_done_sessions[sid] = True
                if err == 'cancelled':
                    self._cancelled_sessions.add(sid)
            if self._player:
                try:
                    self._player.stop_playback()
                except Exception:
                    pass
            await self.event_bus.publish("playback.failed", {"session_id": sid, "error": data.get("error")})
            self._finalized_sessions[sid] = True
            # –í–æ–∑–≤—Ä–∞—Ç –≤ SLEEPING –Ω–µ –∏–Ω–∏—Ü–∏–∏—Ä—É–µ–º, –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ ‚Äî –æ—Ç–º–µ–Ω–∞ (cancelled)
            if err != 'cancelled':
                try:
                    await self.event_bus.publish("mode.request", {
                        "target": AppMode.SLEEPING,
                        "source": "speech_playback"
                    })
                except Exception:
                    pass
        except Exception as e:
            await self._handle_error(e, where="speech.on_grpc_failed", severity="warning")

    async def _on_unified_interrupt(self, event):
        """–ï–î–ò–ù–´–ô –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è"""
        try:
            data = event.get("data", {})
            source = data.get("source", "unknown")
            reason = data.get("reason", "interrupt")
            
            logger.info(f"SpeechPlayback: –ï–î–ò–ù–´–ô –∫–∞–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è, source={source}, reason={reason}")
            
            # –ü–æ–º–µ—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Å–µ—Å—Å–∏—é –∫–∞–∫ –æ—Ç–º–µ–Ω—ë–Ω–Ω—É—é (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if self._current_session_id is not None:
                self._cancelled_sessions.add(self._current_session_id)
                
            # –û—Ç–º–µ–Ω—è–µ–º —Ç–∞–π–º–µ—Ä —Ç–∏—à–∏–Ω—ã, –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω
            try:
                if self._silence_task and not self._silence_task.done():
                    self._silence_task.cancel()
            except Exception:
                pass
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
            if self._player:
                self._player.stop_playback()
            
            # –û—á–∏—â–∞–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏
            self._finalized_sessions.clear()
            
            logger.info("SpeechPlayback: –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ —á–µ—Ä–µ–∑ –ï–î–ò–ù–´–ô –∫–∞–Ω–∞–ª")
            
        except Exception as e:
            await self._handle_error(e, where="speech.on_unified_interrupt", severity="warning")
    
    async def _on_legacy_interrupt(self, event):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π (–ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –≤ –µ–¥–∏–Ω—ã–π –∫–∞–Ω–∞–ª)"""
        try:
            event_type = event.get("type", "unknown")
            data = event.get("data", {})
            
            logger.info(f"SpeechPlayback: –ø–æ–ª—É—á–µ–Ω–æ —É—Å—Ç–∞—Ä–µ–≤—à–µ–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ {event_type}, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤ –ï–î–ò–ù–´–ô –∫–∞–Ω–∞–ª")
            
            # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤ –µ–¥–∏–Ω—ã–π –∫–∞–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            await self.event_bus.publish("playback.cancelled", {
                "session_id": data.get("session_id"),
                "reason": "legacy_interrupt",
                "source": f"legacy_{event_type}",
                "original_event": event_type
            })
            
        except Exception as e:
            await self._handle_error(e, where="speech.on_legacy_interrupt", severity="warning")

    async def _on_app_shutdown(self, event):
        await self.stop()

    async def _on_playback_signal(self, event: Dict[str, Any]):
        """–ü—Ä–∏—ë–º –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ (PCM s16le mono) –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è."""
        try:
            if not self._player:
                return
            data = (event or {}).get("data", {})
            pcm = data.get("pcm")
            if not pcm:
                return
            sr = int(data.get("sample_rate", 0))
            ch = int(data.get("channels", 1))
            gain = float(data.get("gain", 1.0))
            priority = int(data.get("priority", 10))
            pattern = data.get("pattern")

            logger.info(f"üîî playback.signal: pattern={pattern}, bytes={len(pcm)}, sr={sr}, ch={ch}, gain={gain}, prio={priority}")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º sample rate ‚Äî –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –ø–ª–µ–µ—Ä–æ–º
            target_sr = int(self.config['sample_rate'])
            if sr != target_sr:
                logger.debug(f"Signal SR mismatch: got={sr}, player={target_sr} ‚Äî skipping")
                return

            # –î–µ–∫–æ–¥–∏—Ä—É–µ–º PCM s16le mono
            try:
                arr = np.frombuffer(pcm, dtype=np.int16)
            except Exception:
                return

            # –ü—Ä–∏–º–µ–Ω—è–µ–º gain (–æ—Å—Ç–æ—Ä–æ–∂–Ω–æ —Å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ–º)
            try:
                if gain != 1.0:
                    a = arr.astype(np.float32) * max(0.0, min(1.0, gain))
                    a = np.clip(a, -32768.0, 32767.0).astype(np.int16)
                else:
                    a = arr
            except Exception:
                a = arr

            # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∑–∞–ø—É—Å–∫–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
            try:
                meta = {"kind": "signal", "pattern": pattern}
                self._player.add_audio_data(a, priority=priority, metadata=meta)
                state = self._player.state_manager.get_state()
                if state == PlaybackState.PAUSED:
                    self._player.resume_playback()
                elif state != PlaybackState.PLAYING:
                    if not self._player.initialize():
                        await self._handle_error(Exception("player_init_failed"), where="speech.signal.player_init")
                        return
                    if not self._player.start_playback():
                        await self._handle_error(Exception("start_failed"), where="speech.signal.start_playback")
                        return
                    await self.event_bus.publish("playback.started", {"signal": True})
            except Exception as e:
                await self._handle_error(e, where="speech.signal.add_chunk")
        except Exception as e:
            await self._handle_error(e, where="speech.on_playback_signal", severity="warning")

    # -------- Utils --------
    async def _finalize_on_silence(self, sid, timeout: float = 1.5):
        """–§–æ–ª–±—ç–∫: –µ—Å–ª–∏ –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —á–∞–Ω–∫–∞ –Ω–∞—Å—Ç—É–ø–∏–ª–∞ —Ç–∏—à–∏–Ω–∞ –∏ –ø–ª–µ–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º PROCESSING."""
        try:
            start = self._last_audio_ts
            await asyncio.sleep(timeout)
            # –ï—Å–ª–∏ –Ω–µ –±—ã–ª–æ –Ω–æ–≤—ã—Ö —á–∞–Ω–∫–æ–≤
            if self._last_audio_ts == start and self._player:
                # –ï—Å–ª–∏ –±—É—Ñ–µ—Ä –ø—É—Å—Ç ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∏ —Å–µ—Å—Å–∏—é
                buf_empty = (getattr(self._player, 'chunk_buffer', None) and self._player.chunk_buffer.is_empty)
                # –§–∏–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –∑–∞–∫–æ–Ω—á–∏–ª –ø–æ—Ç–æ–∫ (grpc_done), –±—É—Ñ–µ—Ä –ø—É—Å—Ç, –∏ —Å–µ—Å—Å–∏—è –µ—â—ë –Ω–µ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞
                if self._grpc_done_sessions.get(sid) and buf_empty and not self._finalized_sessions.get(sid):
                    # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –¥—Ä–µ–Ω–∞–∂–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                    try:
                        drain_sec = max(0.05, min(0.25, (self.config['buffer_size'] / self.config['sample_rate']) * 4.0))
                        await asyncio.sleep(drain_sec)
                    except Exception:
                        pass
                    # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º
                    try:
                        if self._player:
                            self._player.stop_playback()
                    except Exception:
                        pass
                    await self.event_bus.publish("playback.completed", {"session_id": sid})
                    self._finalized_sessions[sid] = True
                    try:
                        await self.event_bus.publish("mode.request", {
                            "target": AppMode.SLEEPING,
                            "source": "speech_playback"
                        })
                    except Exception:
                        pass
        except asyncio.CancelledError:
            return
        except Exception:
            # –¢–∏—Ö–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —Ñ–æ–ª–±—ç–∫–∞
            pass

    def _on_player_completed(self):
        """–ö–æ–ª–ª–±–µ–∫ –ø–ª–µ–µ—Ä–∞: –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ (–±—É—Ñ–µ—Ä –ø—É—Å—Ç, –ø–æ—Ç–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω)."""
        try:
            sid = self._current_session_id
            if sid is None:
                return
            # –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –∑–∞–≤–µ—Ä—à–∏–ª –ø–æ—Ç–æ–∫ –∏ –º—ã –µ—â–µ –Ω–µ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏
            if self._grpc_done_sessions.get(sid) and not self._finalized_sessions.get(sid):
                loop = asyncio.get_event_loop()
                # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ—â—ë –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
                try:
                    if self._player:
                        self._player.stop_playback()
                except Exception:
                    pass
                loop.create_task(self.event_bus.publish("playback.completed", {"session_id": sid}))
                self._finalized_sessions[sid] = True
                loop.create_task(self.event_bus.publish("mode.request", {
                    "target": AppMode.SLEEPING,
                    "source": "speech_playback"
                }))
        except Exception:
            pass
    async def _handle_error(self, e: Exception, *, where: str, severity: str = "error"):
        if hasattr(self.error_handler, 'handle'):
            await self.error_handler.handle(
                error=e,
                category="speech_playback",
                severity=severity,
                context={"where": where}
            )
        else:
            logger.error(f"Speech playback error at {where}: {e}")

    def get_status(self) -> Dict[str, Any]:
        return {
            "initialized": self._initialized,
            "running": self._running,
            "player": (self._player.get_status() if self._player else {}),
        }
