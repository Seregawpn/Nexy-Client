#!/usr/bin/env python3
"""
AudioGenerator with Azure Speech Services
High-quality TTS with proper authentication
"""

import asyncio
import logging
import tempfile
import os
from typing import Optional, AsyncGenerator
import numpy as np
from pydub import AudioSegment
import io
import azure.cognitiveservices.speech as speechsdk
from config import Config
from utils.text_utils import split_into_sentences

logger = logging.getLogger(__name__)

class AudioGenerator:
    """
    Audio generator with Azure Speech Services
    High-quality TTS with proper authentication
    """
    
    def __init__(self, voice: str = "en-US-JennyNeural"):
        self.voice = voice
        self.is_generating = False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Azure
        if not Config.SPEECH_KEY or not Config.SPEECH_REGION:
            raise ValueError("Azure Speech Services –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ SPEECH_KEY –∏ SPEECH_REGION –≤ config.env")
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Azure Speech Services
        self.speech_config = speechsdk.SpeechConfig(
            subscription=Config.SPEECH_KEY,
            region=Config.SPEECH_REGION
        )
        self.speech_config.speech_synthesis_voice_name = self.voice
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ñ–æ—Ä–º–∞—Ç –∞—É–¥–∏–æ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ 48000Hz 16-bit mono PCM
        self.speech_config.set_speech_synthesis_output_format(
            speechsdk.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm
        )
        
        logger.info(f"üéµ AudioGenerator initialized with voice: {self.voice}")
        logger.info(f"‚úÖ Using Azure Speech Services - Region: {Config.SPEECH_REGION}")
        logger.info(f"üéµ Audio format: 48000Hz 16-bit mono PCM")
    
    def _is_russian_text(self, text: str) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
        NOTE: This method is kept for compatibility but always returns False
        since we only work with English now.
        """
        return False  # Always use English/Azure TTS
    
    async def generate_audio(self, text: str) -> Optional[np.ndarray]:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç numpy –º–∞—Å—Å–∏–≤
        """
        logger.info(f"üéµ [AUDIO_GEN] generate_audio() –≤—ã–∑–≤–∞–Ω –¥–ª—è —Ç–µ–∫—Å—Ç–∞: '{text[:50]}...'")
        
        if not text or not text.strip():
            logger.warning("‚ö†Ô∏è [AUDIO_GEN] –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ")
            return None
        
        try:
            self.is_generating = True
            logger.info(f"üéµ [AUDIO_GEN] Generating audio for: {text[:50]}...")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Azure Speech Services
            logger.info("üá∫üá∏ [AUDIO_GEN] Using Azure Speech Services for all text")
            result = await self._generate_with_azure_tts(text)
            logger.info(f"üéµ [AUDIO_GEN] generate_audio() –∑–∞–≤–µ—Ä—à–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {len(result) if result is not None else 'None'} —Å—ç–º–ø–ª–æ–≤")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Audio generation error: {e}")
            return None
        finally:
            self.is_generating = False
    
    async def _generate_with_azure_tts(self, text: str) -> Optional[np.ndarray]:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ —Å –ø–æ–º–æ—â—å—é Azure Speech Services"""
        logger.info(f"üéµ [AZURE_TTS] _generate_with_azure_tts() –≤—ã–∑–≤–∞–Ω –¥–ª—è: '{text[:30]}...'")
        
        try:
            # –°–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä —Ä–µ—á–∏
            logger.info(f"üéµ [AZURE_TTS] –°–æ–∑–¥–∞—é —Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä —Ä–µ—á–∏...")
            synthesizer = speechsdk.SpeechSynthesizer(
                speech_config=self.speech_config,
                audio_config=None  # –ë—É–¥–µ–º –ø–æ–ª—É—á–∞—Ç—å –∞—É–¥–∏–æ –≤ –ø–∞–º—è—Ç—å
            )
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏
            logger.info(f"üéµ [AZURE_TTS] –í—ã–ø–æ–ª–Ω—è—é —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏...")
            result = synthesizer.speak_text_async(text).get()
            logger.info(f"üéµ [AZURE_TTS] –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∏–Ω—Ç–µ–∑–∞: {result.reason}")
            
            if result.reason == speechsdk.ResultReason.SynthesizingAudioCompleted:
                # –ü–æ–ª—É—á–∞–µ–º –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ
                audio_data = result.audio_data
                logger.info(f"üéµ [AZURE_TTS] –ü–æ–ª—É—á–µ–Ω—ã –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ: {len(audio_data)} –±–∞–π—Ç")
                
                if len(audio_data) == 0:
                    logger.error("‚ùå [AZURE_TTS] –ù–µ –ø–æ–ª—É—á–µ–Ω—ã –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ")
                    return None
                
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ numpy –º–∞—Å—Å–∏–≤
                logger.info(f"üéµ [AZURE_TTS] –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –≤ AudioSegment...")
                audio_segment = AudioSegment.from_wav(io.BytesIO(audio_data))
                logger.info(f"üéµ [AZURE_TTS] –ò—Å—Ö–æ–¥–Ω—ã–π AudioSegment: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                
                # Azure TTS —É–∂–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ 48000Hz 16-bit mono, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                if audio_segment.channels != 1:
                    audio_segment = audio_segment.set_channels(1)
                    logger.info(f"üéµ [AZURE_TTS] –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ –º–æ–Ω–æ: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                else:
                    logger.info(f"üéµ [AZURE_TTS] –ê—É–¥–∏–æ —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                
                samples = np.array(audio_segment.get_array_of_samples()).astype(np.int16)
                logger.info(f"‚úÖ [AZURE_TTS] –ê—É–¥–∏–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {len(samples)} —Å—ç–º–ø–ª–æ–≤")
                logger.info(f"üìä [AZURE_TTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—ç–º–ø–ª–æ–≤: min={samples.min()}, max={samples.max()}, mean={samples.mean():.2f}")
                return samples
                
            elif result.reason == speechsdk.ResultReason.Canceled:
                cancellation_details = result.cancellation_details
                logger.error(f"‚ùå Azure TTS –æ—Ç–º–µ–Ω–µ–Ω: {cancellation_details.reason}")
                if cancellation_details.reason == speechsdk.CancellationReason.Error:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞: {cancellation_details.error_details}")
                return None
            else:
                logger.error(f"‚ùå Azure TTS: –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result.reason}")
                return None
            
        except Exception as e:
            logger.error(f"‚ùå Azure TTS –æ—à–∏–±–∫–∞: {e}")
            raise
    
    async def generate_streaming_audio(self, text: str) -> AsyncGenerator[np.ndarray, None]:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ –ø–æ —á–∞—Å—Ç—è–º –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –ø–µ—Ä–µ–¥–∞—á–∏
        """
        logger.info(f"üéµ [STREAM_GEN] generate_streaming_audio() –≤—ã–∑–≤–∞–Ω –¥–ª—è: '{text[:50]}...'")
        
        if not text or not text.strip():
            logger.warning("‚ö†Ô∏è [STREAM_GEN] –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
            return
        
        try:
            self.is_generating = True
            logger.info(f"üéµ [STREAM_GEN] Streaming generation for: {text[:50]}...")
            
            # Split text into sentences
            sentences = split_into_sentences(text)
            logger.info(f"üìù [STREAM_GEN] Split into {len(sentences)} sentences")
            
            valid_sentences = 0
            generated_chunks = 0
            
            for i, sentence in enumerate(sentences):
                # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
                if not sentence or not sentence.strip():
                    logger.debug(f"üîá [STREAM_GEN] –ü—Ä–æ–ø—É—Å–∫–∞—é –ø—É—Å—Ç–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {i+1}")
                    continue
                
                valid_sentences += 1
                logger.info(f"üéµ [STREAM_GEN] Generating sentence {valid_sentences}/{len(sentences)}: {sentence[:30]}...")
                
                # Generate audio for sentence
                logger.info(f"üéµ [STREAM_GEN] –í—ã–∑—ã–≤–∞—é generate_audio() –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è {valid_sentences}")
                audio = await self.generate_audio(sentence)
                logger.info(f"üéµ [STREAM_GEN] generate_audio() –≤–µ—Ä–Ω—É–ª: {len(audio) if audio is not None else 'None'} —Å—ç–º–ø–ª–æ–≤")
                
                # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞—É–¥–∏–æ –Ω–µ –ø—É—Å—Ç–æ–µ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
                if audio is not None and len(audio) > 0:
                    generated_chunks += 1
                    logger.info(f"‚úÖ [STREAM_GEN] Sentence {valid_sentences} ready: {len(audio)} samples - –û–¢–ü–†–ê–í–õ–Ø–Æ")
                    yield audio
                else:
                    logger.warning(f"‚ö†Ô∏è [STREAM_GEN] Failed to generate audio for sentence {valid_sentences} - –ù–ï –û–¢–ü–†–ê–í–õ–Ø–Æ –ø—É—Å—Ç–æ–π —á–∞–Ω–∫")
            
            logger.info(f"‚úÖ [STREAM_GEN] Streaming generation completed: {generated_chunks} —á–∞–Ω–∫–æ–≤ –∏–∑ {valid_sentences} –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π")
            
        except Exception as e:
            logger.error(f"‚ùå [STREAM_GEN] Streaming generation error: {e}")
        finally:
            self.is_generating = False
            logger.info(f"üéµ [STREAM_GEN] generate_streaming_audio() –∑–∞–≤–µ—Ä—à–µ–Ω")
    
    def set_voice(self, voice: str):
        """
        Sets new voice
        """
        if voice and voice.strip():
            self.voice = voice
            self.speech_config.speech_synthesis_voice_name = voice
            logger.info(f"üéµ Voice changed to: {voice}")
        else:
            logger.warning(f"‚ö†Ô∏è Invalid voice: {voice}")
    
    def get_voice(self) -> str:
        """
        Returns current voice
        """
        return self.voice
    
    def stop_generation(self):
        """
        Stops audio generation
        """
        logger.info("üõë Stopping audio generation")
        self.is_generating = False
    
    def is_busy(self) -> bool:
        """
        Checks if audio is being generated
        """
        return self.is_generating

