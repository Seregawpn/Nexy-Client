#!/usr/bin/env python3
"""
AudioGenerator with Azure Speech Services
High-quality TTS with proper authentication
"""

import asyncio
import logging
import tempfile
import os
from typing import Optional, AsyncGenerator
import numpy as np
from pydub import AudioSegment
import io
try:
    import azure.cognitiveservices.speech as speechsdk
    _AZURE_SDK_AVAILABLE = True
except Exception:
    speechsdk = None  # type: ignore
    _AZURE_SDK_AVAILABLE = False

from config import Config
from utils.text_utils import split_into_sentences

logger = logging.getLogger(__name__)

class AudioGenerator:
    """
    Audio generator with Azure Speech Services
    High-quality TTS with proper authentication
    """
    
    def __init__(self, voice: str = "en-US-JennyNeural"):
        self.voice = voice
        self.is_generating = False

        # –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã - –¢–û–õ–¨–ö–û AZURE TTS
        self._use_azure = bool(_AZURE_SDK_AVAILABLE and Config.SPEECH_KEY and Config.SPEECH_REGION)
        
        # Edge TTS –æ—Ç–∫–ª—é—á–µ–Ω (–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã)
        self._edge_tts_available = False
        self._use_edge_tts = False
        
        # macOS say fallback (—Ç–æ–ª—å–∫–æ –¥–ª—è —ç–∫—Å—Ç—Ä–µ–Ω–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤)
        self._use_macos_say = os.getenv('USE_MACOS_SAY', 'false').lower() == 'true'

        if self._use_azure:
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Azure Speech Services
            self.speech_config = speechsdk.SpeechConfig(
                subscription=Config.SPEECH_KEY,
                region=Config.SPEECH_REGION
            )
            self.speech_config.speech_synthesis_voice_name = self.voice
            # –§–æ—Ä–º–∞—Ç: 48000Hz 16-bit mono PCM
            self.speech_config.set_speech_synthesis_output_format(
                speechsdk.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm
            )
            logger.info(f"üéµ AudioGenerator initialized with voice: {self.voice}")
            logger.info(f"‚úÖ Using Azure Speech Services (PRIMARY) - Region: {Config.SPEECH_REGION}")
            logger.info(f"üéµ Audio format: 48000Hz 16-bit mono PCM")
            logger.info(f"üö´ Edge TTS –æ—Ç–∫–ª—é—á–µ–Ω (–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã)")
        else:
            self.speech_config = None
            if self._use_macos_say:
                logger.info("üçé macOS say –≤–∫–ª—é—á–µ–Ω ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π TTS (fallback)")
            else:
                logger.warning("‚ö†Ô∏è Azure TTS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî –∏—Å–ø–æ–ª—å–∑—É—é fallback –º–µ—Ç–æ–¥—ã")
    
    def _is_russian_text(self, text: str) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
        NOTE: This method is kept for compatibility but always returns False
        since we only work with English now.
        """
        return False  # Always use English/Azure TTS
    
    async def generate_audio(self, text: str) -> Optional[np.ndarray]:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç numpy –º–∞—Å—Å–∏–≤
        """
        logger.info(f"üéµ [AUDIO_GEN] generate_audio() –≤—ã–∑–≤–∞–Ω –¥–ª—è —Ç–µ–∫—Å—Ç–∞: '{text[:50]}...'")
        
        if not text or not text.strip():
            logger.warning("‚ö†Ô∏è [AUDIO_GEN] –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ")
            return None
        
        try:
            self.is_generating = True
            logger.info(f"üéµ [AUDIO_GEN] Generating audio for: {text[:50]}...")

            if self._use_azure:
                logger.info("üá∫üá∏ [AUDIO_GEN] Using Azure Speech Services (PRIMARY)")
                result = await self._generate_with_azure_tts(text)
                # –ï—Å–ª–∏ Azure –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback
                if result is None:
                    logger.warning("üéõÔ∏è [AUDIO_GEN] Azure failed ‚Äî trying fallback methods")
                    if self._use_macos_say:
                        logger.info("üçé [AUDIO_GEN] Trying macOS say fallback")
                        result = await self._generate_with_macos_say(text)
                    # –ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞
                    if result is None:
                        logger.warning("üéõÔ∏è [AUDIO_GEN] All methods failed ‚Äî using improved fallback")
                        result = self._generate_with_improved_fallback(text)
            elif self._use_macos_say:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º macOS say (–µ—Å–ª–∏ Azure –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)
                logger.info("üçé [AUDIO_GEN] Using macOS say (Azure unavailable)")
                result = await self._generate_with_macos_say(text)
                if result is None:
                    logger.warning("üéõÔ∏è [AUDIO_GEN] macOS say failed ‚Äî using improved fallback")
                    result = self._generate_with_improved_fallback(text)
            else:
                # –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback
                logger.warning("üéõÔ∏è [AUDIO_GEN] No TTS available ‚Äî using improved fallback")
                result = self._generate_with_improved_fallback(text)

            logger.info(f"üéµ [AUDIO_GEN] generate_audio() –∑–∞–≤–µ—Ä—à–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {len(result) if isinstance(result, np.ndarray) else 'None'} —Å—ç–º–ø–ª–æ–≤")
            return result

        except Exception as e:
            logger.error(f"‚ùå Audio generation error: {e}")
            return None
        finally:
            self.is_generating = False
    
    async def _generate_with_azure_tts(self, text: str) -> Optional[np.ndarray]:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ —Å –ø–æ–º–æ—â—å—é Azure Speech Services"""
        logger.info(f"üéµ [AZURE_TTS] _generate_with_azure_tts() –≤—ã–∑–≤–∞–Ω –¥–ª—è: '{text[:30]}...'")
        
        try:
            # –°–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä —Ä–µ—á–∏
            logger.info(f"üéµ [AZURE_TTS] –°–æ–∑–¥–∞—é —Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä —Ä–µ—á–∏...")
            synthesizer = speechsdk.SpeechSynthesizer(
                speech_config=self.speech_config,
                audio_config=None  # –ë—É–¥–µ–º –ø–æ–ª—É—á–∞—Ç—å –∞—É–¥–∏–æ –≤ –ø–∞–º—è—Ç—å
            )
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏
            logger.info(f"üéµ [AZURE_TTS] –í—ã–ø–æ–ª–Ω—è—é —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏...")
            result = synthesizer.speak_text_async(text).get()
            logger.info(f"üéµ [AZURE_TTS] –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∏–Ω—Ç–µ–∑–∞: {result.reason}")
            
            if result.reason == speechsdk.ResultReason.SynthesizingAudioCompleted:
                # –ü–æ–ª—É—á–∞–µ–º –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ
                audio_data = result.audio_data
                logger.info(f"üéµ [AZURE_TTS] –ü–æ–ª—É—á–µ–Ω—ã –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ: {len(audio_data)} –±–∞–π—Ç")
                
                if len(audio_data) == 0:
                    logger.error("‚ùå [AZURE_TTS] –ù–µ –ø–æ–ª—É—á–µ–Ω—ã –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ")
                    return None
                
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ numpy –º–∞—Å—Å–∏–≤
                logger.info(f"üéµ [AZURE_TTS] –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –≤ AudioSegment...")
                audio_segment = AudioSegment.from_wav(io.BytesIO(audio_data))
                logger.info(f"üéµ [AZURE_TTS] –ò—Å—Ö–æ–¥–Ω—ã–π AudioSegment: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                
                # Azure TTS —É–∂–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ 48000Hz 16-bit mono, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                if audio_segment.channels != 1:
                    audio_segment = audio_segment.set_channels(1)
                    logger.info(f"üéµ [AZURE_TTS] –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ –º–æ–Ω–æ: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                else:
                    logger.info(f"üéµ [AZURE_TTS] –ê—É–¥–∏–æ —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ: {audio_segment.frame_rate}Hz, {audio_segment.channels}ch, {len(audio_segment)}ms")
                
                samples = np.array(audio_segment.get_array_of_samples()).astype(np.int16)
                logger.info(f"‚úÖ [AZURE_TTS] –ê—É–¥–∏–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {len(samples)} —Å—ç–º–ø–ª–æ–≤")
                logger.info(f"üìä [AZURE_TTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—ç–º–ø–ª–æ–≤: min={samples.min()}, max={samples.max()}, mean={samples.mean():.2f}")
                return samples
                
            elif result.reason == speechsdk.ResultReason.Canceled:
                cancellation_details = result.cancellation_details
                logger.error(f"‚ùå Azure TTS –æ—Ç–º–µ–Ω–µ–Ω: {cancellation_details.reason}")
                if cancellation_details.reason == speechsdk.CancellationReason.Error:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞: {cancellation_details.error_details}")
                return None
            else:
                logger.error(f"‚ùå Azure TTS: –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result.reason}")
                return None
            
        except Exception as e:
            logger.error(f"‚ùå Azure TTS –æ—à–∏–±–∫–∞: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º None, —á—Ç–æ–±—ã –≤—ã–∑–≤–∞—Ç—å —Ñ–æ–ª–±—ç–∫ (Edge TTS / sine)
            return None

    async def _generate_with_edge_tts(self, text: str) -> Optional[np.ndarray]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ edge-tts —Å retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º."""
        import edge_tts
        import asyncio
        
        max_retries = 3
        retry_delay = 1.0
        
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    logger.info(f"üîÑ [EDGE_TTS] Retry {attempt + 1}/{max_retries} —á–µ—Ä–µ–∑ {retry_delay}s...")
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 1.5  # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–ø—ã—Ç–∫–∏
                communicate = edge_tts.Communicate(
                    text=text,
                    voice=self.voice,
                    rate=Config.EDGE_TTS_RATE,
                    volume=Config.EDGE_TTS_VOLUME,
                )
                
                audio_bytes = b""
                try:
                    async for chunk in communicate.stream():
                        if chunk["type"] == "audio":
                            audio_bytes += chunk["data"]
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è [EDGE_TTS] WebSocket –æ—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {e}")
                    continue
                
                if not audio_bytes:
                    logger.warning(f"‚ö†Ô∏è [EDGE_TTS] Empty audio data –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}")
                    continue

                # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∞—É–¥–∏–æ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
                seg = None
                for format_attempt in ['auto', 'mp3', 'wav']:
                    try:
                        if format_attempt == 'auto':
                            seg = AudioSegment.from_file(io.BytesIO(audio_bytes))
                        elif format_attempt == 'mp3':
                            seg = AudioSegment.from_mp3(io.BytesIO(audio_bytes))
                        elif format_attempt == 'wav':
                            seg = AudioSegment.from_wav(io.BytesIO(audio_bytes))
                        break
                    except Exception as e:
                        if format_attempt == 'wav':  # –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞
                            logger.warning(f"‚ö†Ô∏è [EDGE_TTS] Audio decode failed –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {e}")
                            break
                        continue
                        
                if seg is None:
                    continue
                        
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                if seg.frame_rate != 48000:
                    seg = seg.set_frame_rate(48000)
                if seg.channels != 1:
                    seg = seg.set_channels(1)
                    
                samples = np.array(seg.get_array_of_samples(), dtype=np.int16)
                logger.info(f"‚úÖ [EDGE_TTS] Success –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {len(samples)} samples")
                return samples
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è [EDGE_TTS] Attempt {attempt + 1} failed: {e}")
                if attempt == max_retries - 1:
                    logger.error(f"‚ùå [EDGE_TTS] All {max_retries} attempts failed")
                    return None
                continue
        
        return None

    async def _generate_with_macos_say(self, text: str) -> Optional[np.ndarray]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π macOS say command"""
        try:
            import subprocess
            import tempfile
            from pydub import AudioSegment
            
            logger.info(f"üçé [MACOS_SAY] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª—è: '{text[:50]}...'")
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            with tempfile.NamedTemporaryFile(suffix='.aiff', delete=False) as temp_file:
                temp_path = temp_file.name
            
            try:
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ say
                cmd = [
                    'say',
                    '-v', 'Samantha',  # –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å
                    '-r', '180',       # –°–∫–æ—Ä–æ—Å—Ç—å (—Å–ª–æ–≤ –≤ –º–∏–Ω—É—Ç—É)
                    '-o', temp_path,   # –í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª
                    text
                ]
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
                
                if result.returncode == 0 and os.path.exists(temp_path):
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                    seg = AudioSegment.from_file(temp_path)
                    
                    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É: 48000Hz mono
                    if seg.frame_rate != 48000:
                        seg = seg.set_frame_rate(48000)
                    if seg.channels != 1:
                        seg = seg.set_channels(1)
                    
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ numpy int16
                    samples = np.array(seg.get_array_of_samples(), dtype=np.int16)
                    
                    logger.info(f"‚úÖ [MACOS_SAY] –£—Å–ø–µ—à–Ω–æ: {len(samples)} —Å—ç–º–ø–ª–æ–≤, {len(samples)/48000:.1f}s")
                    return samples
                    
                else:
                    logger.error(f"‚ùå [MACOS_SAY] –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {result.stderr}")
                    return None
                    
            finally:
                # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                try:
                    os.unlink(temp_path)
                except:
                    pass
                    
        except subprocess.TimeoutExpired:
            logger.error("‚è∞ [MACOS_SAY] –¢–∞–π–º–∞—É—Ç 15s")
            return None
        except Exception as e:
            logger.error(f"‚ùå [MACOS_SAY] –û—à–∏–±–∫–∞: {e}")
            return None

    def _generate_with_improved_fallback(self, text: str) -> Optional[np.ndarray]:
        """
        –£–ª—É—á—à–µ–Ω–Ω—ã–π –ª–æ–∫–∞–ª—å–Ω—ã–π fallback: –∫–æ—Ä–æ—Ç–∫–∏–π beep –≤–º–µ—Å—Ç–æ –¥–ª–∏–Ω–Ω–æ–≥–æ —Ç–æ–Ω–∞
        –ó–∞–º–µ–Ω—è–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã–π sine-wave –Ω–∞ –∫—Ä–∞—Ç–∫–∏–π —Å–∏–≥–Ω–∞–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        """
        try:
            logger.warning(f"üéõÔ∏è [IMPROVED_FALLBACK] TTS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, —Å–æ–∑–¥–∞—é –∫–æ—Ä–æ—Ç–∫–∏–π beep")
            logger.info(f"üéõÔ∏è [IMPROVED_FALLBACK] –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: '{text[:50]}...'")
            
            sr = 48000
            
            # –ö–æ—Ä–æ—Ç–∫–∏–π –¥–≤–æ–π–Ω–æ–π beep (0.6 —Å–µ–∫—É–Ω–¥—ã) –≤–º–µ—Å—Ç–æ –¥–ª–∏–Ω–Ω–æ–≥–æ —Ç–æ–Ω–∞
            beep1_dur = 0.15  # 150ms –ø–µ—Ä–≤—ã–π beep
            pause_dur = 0.1   # 100ms –ø–∞—É–∑–∞
            beep2_dur = 0.15  # 150ms –≤—Ç–æ—Ä–æ–π beep
            final_pause = 0.2 # 200ms —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –ø–∞—É–∑–∞
            
            total_duration = beep1_dur + pause_dur + beep2_dur + final_pause
            total_samples = int(sr * total_duration)
            
            # –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞–ª
            audio = np.zeros(total_samples, dtype=np.float32)
            
            # –ü–µ—Ä–≤—ã–π beep (800Hz)
            beep1_samples = int(sr * beep1_dur)
            t1 = np.linspace(0, beep1_dur, beep1_samples, endpoint=False)
            beep1 = 0.3 * np.sin(2 * np.pi * 800 * t1)
            # –ú—è–≥–∫–∏–π fade-in/out
            fade_samples = int(0.02 * sr)  # 20ms fade
            beep1[:fade_samples] *= np.linspace(0, 1, fade_samples)
            beep1[-fade_samples:] *= np.linspace(1, 0, fade_samples)
            audio[:beep1_samples] = beep1
            
            # –í—Ç–æ—Ä–æ–π beep (1000Hz) –ø–æ—Å–ª–µ –ø–∞—É–∑—ã
            beep2_start = int(sr * (beep1_dur + pause_dur))
            beep2_samples = int(sr * beep2_dur)
            t2 = np.linspace(0, beep2_dur, beep2_samples, endpoint=False)
            beep2 = 0.3 * np.sin(2 * np.pi * 1000 * t2)
            beep2[:fade_samples] *= np.linspace(0, 1, fade_samples)
            beep2[-fade_samples:] *= np.linspace(1, 0, fade_samples)
            audio[beep2_start:beep2_start + beep2_samples] = beep2
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ int16
            audio_int16 = np.asarray(audio * 32767, dtype=np.int16)
            
            logger.info(f"‚úÖ [IMPROVED_FALLBACK] –°–æ–∑–¥–∞–Ω –¥–≤–æ–π–Ω–æ–π beep: {len(audio_int16)} —Å—ç–º–ø–ª–æ–≤, {total_duration:.1f}s")
            return audio_int16
            
        except Exception as e:
            logger.error(f"‚ùå [IMPROVED_FALLBACK] –û—à–∏–±–∫–∞: {e}")
            # –ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ - —Ç–∏—à–∏–Ω–∞
            try:
                return np.zeros(int(0.5 * 48000), dtype=np.int16)  # 0.5 —Å–µ–∫ —Ç–∏—à–∏–Ω—ã
            except:
                return None

    def _generate_with_sine_fallback(self, text: str) -> Optional[np.ndarray]:
        """
        –õ–æ–∫–∞–ª—å–Ω—ã–π —Ñ–æ–ª–±—ç–∫-–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä: —Å–æ–∑–¥–∞–µ—Ç –º–æ–Ω–æ-—Å–∏–≥–Ω–∞–ª 48kHz int16.
        –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ –¥–ª–∏–Ω–µ —Ç–µ–∫—Å—Ç–∞ (–¥–æ 3.5—Å).
        """
        try:
            sr = 48000
            # 50 –º—Å –Ω–∞ —Å–∏–º–≤–æ–ª, –æ—Ç 0.6—Å –¥–æ 3.5—Å
            duration_sec = min(3.5, max(0.6, 0.05 * max(1, len(text.strip()))))
            t = np.linspace(0, duration_sec, int(sr * duration_sec), endpoint=False, dtype=np.float32)
            # –ù–µ–±–æ–ª—å—à–∞—è –º–µ–ª–æ–¥–∏—è: A4 440 –ì—Ü —Å –∞–º–ø–ª–∏—Ç—É–¥–Ω–æ–π –æ–≥–∏–±–∞—é—â–µ–π
            freq = 440.0
            envelope = np.minimum(1.0, np.linspace(0, 1.0, int(0.1 * sr)))
            envelope = np.pad(envelope, (0, len(t) - len(envelope)), constant_values=(0, 1.0))
            wave = 0.2 * np.sin(2 * np.pi * freq * t) * envelope
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ int16 –º–æ–Ω–æ
            audio = np.asarray(wave * 32767, dtype=np.int16)
            return audio
        except Exception as e:
            logger.error(f"‚ùå Fallback synth error: {e}")
            return None
    
    async def generate_streaming_audio(self, text: str) -> AsyncGenerator[np.ndarray, None]:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ –ø–æ —á–∞—Å—Ç—è–º –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –ø–µ—Ä–µ–¥–∞—á–∏
        """
        logger.info(f"üéµ [STREAM_GEN] generate_streaming_audio() –≤—ã–∑–≤–∞–Ω –¥–ª—è: '{text[:50]}...'")
        
        if not text or not text.strip():
            logger.warning("‚ö†Ô∏è [STREAM_GEN] –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
            return
        
        try:
            self.is_generating = True
            logger.info(f"üéµ [STREAM_GEN] Streaming generation for: {text[:50]}...")
            
            # Split text into sentences
            sentences = split_into_sentences(text)
            logger.info(f"üìù [STREAM_GEN] Split into {len(sentences)} sentences")
            
            valid_sentences = 0
            generated_chunks = 0
            
            for i, sentence in enumerate(sentences):
                # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
                if not sentence or not sentence.strip():
                    logger.debug(f"üîá [STREAM_GEN] –ü—Ä–æ–ø—É—Å–∫–∞—é –ø—É—Å—Ç–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {i+1}")
                    continue
                
                valid_sentences += 1
                logger.info(f"üéµ [STREAM_GEN] Generating sentence {valid_sentences}/{len(sentences)}: {sentence[:30]}...")
                
                # Generate audio for sentence
                logger.info(f"üéµ [STREAM_GEN] –í—ã–∑—ã–≤–∞—é generate_audio() –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è {valid_sentences}")
                audio = await self.generate_audio(sentence)
                logger.info(f"üéµ [STREAM_GEN] generate_audio() –≤–µ—Ä–Ω—É–ª: {len(audio) if audio is not None else 'None'} —Å—ç–º–ø–ª–æ–≤")
                
                # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞—É–¥–∏–æ –Ω–µ –ø—É—Å—Ç–æ–µ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
                if audio is not None and len(audio) > 0:
                    generated_chunks += 1
                    logger.info(f"‚úÖ [STREAM_GEN] Sentence {valid_sentences} ready: {len(audio)} samples - –û–¢–ü–†–ê–í–õ–Ø–Æ")
                    yield audio
                else:
                    logger.warning(f"‚ö†Ô∏è [STREAM_GEN] Failed to generate audio for sentence {valid_sentences} - –ù–ï –û–¢–ü–†–ê–í–õ–Ø–Æ –ø—É—Å—Ç–æ–π —á–∞–Ω–∫")
            
            logger.info(f"‚úÖ [STREAM_GEN] Streaming generation completed: {generated_chunks} —á–∞–Ω–∫–æ–≤ –∏–∑ {valid_sentences} –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π")
            
        except Exception as e:
            logger.error(f"‚ùå [STREAM_GEN] Streaming generation error: {e}")
        finally:
            self.is_generating = False
            logger.info(f"üéµ [STREAM_GEN] generate_streaming_audio() –∑–∞–≤–µ—Ä—à–µ–Ω")
    
    def set_voice(self, voice: str):
        """
        Sets new voice
        """
        if voice and voice.strip():
            self.voice = voice
            self.speech_config.speech_synthesis_voice_name = voice
            logger.info(f"üéµ Voice changed to: {voice}")
        else:
            logger.warning(f"‚ö†Ô∏è Invalid voice: {voice}")
    
    def get_voice(self) -> str:
        """
        Returns current voice
        """
        return self.voice
    
    def stop_generation(self):
        """
        Stops audio generation
        """
        logger.info("üõë Stopping audio generation")
        self.is_generating = False
    
    def is_busy(self) -> bool:
        """
        Checks if audio is being generated
        """
        return self.is_generating
