#!/usr/bin/env python3
"""
–ù–æ–≤—ã–π gRPC —Å–µ—Ä–≤–µ—Ä —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
–ó–∞–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ä—ã–π grpc_server.py —Å –ø–æ–ª–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –º–æ–¥—É–ª—å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
"""

import asyncio
import logging
import grpc.aio
from concurrent.futures import ThreadPoolExecutor
import numpy as np
import time
from datetime import datetime
from typing import Dict, Any, Optional, AsyncGenerator

# Protobuf —Ñ–∞–π–ª—ã –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑ streaming.proto
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import streaming_pb2
import streaming_pb2_grpc

# –ò–º–ø–æ—Ä—Ç –Ω–æ–≤—ã—Ö –º–æ–¥—É–ª–µ–π
from .grpc_service_manager import GrpcServiceManager

# –ò–º–ø–æ—Ä—Ç—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏)
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../../..'))
from monitoring import record_request, set_active_connections, get_metrics, get_status

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ –≤ main.py
logger = logging.getLogger(__name__)

def _get_dtype_string(dtype) -> str:
    """–ü—Ä–∞–≤–∏–ª—å–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç numpy dtype –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è protobuf"""
    if hasattr(dtype, 'name'):
        return dtype.name  # np.int16 -> 'int16'
    dtype_str = str(dtype)
    if dtype_str == '<i2':
        return 'int16'
    elif dtype_str == '<f4':
        return 'float32'
    elif dtype_str == '<f8':
        return 'float64'
    return dtype_str

class NewStreamingServicer(streaming_pb2_grpc.StreamingServiceServicer):
    """–ù–æ–≤—ã–π gRPC —Å–µ—Ä–≤–∏—Å —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π"""
    
    def __init__(self):
        logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ gRPC —Å–µ—Ä–≤–µ—Ä–∞ —Å –º–æ–¥—É–ª—è–º–∏...")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä—ã –º–æ–¥—É–ª–µ–π
        self.grpc_service_manager = GrpcServiceManager()
        self.interrupt_manager = None
        
        # –§–ª–∞–≥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        self.is_initialized = False
        
        logger.info("‚úÖ –ù–æ–≤—ã–π gRPC —Å–µ—Ä–≤–µ—Ä —Å–æ–∑–¥–∞–Ω")
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π"""
        if self.is_initialized:
            logger.info("‚ö†Ô∏è –°–µ—Ä–≤–µ—Ä —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        
        try:
            logger.info("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π...")
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º gRPC Service Manager
            await self.grpc_service_manager.initialize()
            logger.info("‚úÖ gRPC Service Manager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Interrupt Manager –∏–∑ gRPC Service Manager
            self.interrupt_manager = self.grpc_service_manager.modules.get('interrupt_handling')
            if not self.interrupt_manager:
                raise RuntimeError("Interrupt Manager module not found in GrpcServiceManager")
            logger.info("‚úÖ Interrupt Manager –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ gRPC —Å–µ—Ä–≤–∏—Å—É")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –º–æ–¥—É–ª–∏
            await self.grpc_service_manager.start()
            logger.info("‚úÖ –í—Å–µ –º–æ–¥—É–ª–∏ –∑–∞–ø—É—â–µ–Ω—ã")
            
            self.is_initialized = True
            logger.info("üéâ –ù–æ–≤—ã–π gRPC —Å–µ—Ä–≤–µ—Ä –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
            return False
    
    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö —Ä–µ—Å—É—Ä—Å–æ–≤"""
        try:
            logger.info("üßπ –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –Ω–æ–≤–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞...")
            
            if self.is_initialized:
                # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –º–æ–¥—É–ª–∏
                await self.grpc_service_manager.stop()
                logger.info("‚úÖ –í—Å–µ –º–æ–¥—É–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")

                # –û—á–∏—â–∞–µ–º gRPC Service Manager
                await self.grpc_service_manager.cleanup()
                logger.info("‚úÖ gRPC Service Manager –æ—á–∏—â–µ–Ω")
            
            self.is_initialized = False
            self.interrupt_manager = None
            logger.info("‚úÖ –ù–æ–≤—ã–π —Å–µ—Ä–≤–µ—Ä –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –Ω–æ–≤–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
    
    async def StreamAudio(self, request: streaming_pb2.StreamRequest, context) -> AsyncGenerator[streaming_pb2.StreamResponse, None]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ StreamRequest —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–µ –º–æ–¥—É–ª–∏ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º"""
        start_time = time.time()
        session_id = request.session_id or f"session_{datetime.now().timestamp()}"
        hardware_id = request.hardware_id or "unknown"
        
        logger.info(f"üì® –ü–æ–ª—É—á–µ–Ω StreamRequest: session={session_id}, hardware_id={hardware_id}")
        logger.info(f"üì® StreamRequest –¥–∞–Ω–Ω—ã–µ: prompt_len={len(request.prompt)}, screenshot_len={len(request.screenshot) if request.screenshot else 0}")
        
        try:
            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            current_connections = get_metrics().get('active_connections', 0)
            set_active_connections(current_connections + 1)
            # –í –Ω–æ–≤–æ–º protobuf –Ω–µ—Ç interrupt_flag –≤ StreamRequest
            # –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ –æ—Ç–¥–µ–ª—å–Ω—ã–π InterruptSession API
            
            if not self.interrupt_manager:
                logger.error("Interrupt Manager –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∑–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω")
                yield streaming_pb2.StreamResponse(error_message="Interrupt manager unavailable")
                return

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            if self.interrupt_manager.should_interrupt(hardware_id):
                logger.info(f"üõë –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ –¥–ª—è {hardware_id}, –æ—Ç–∫–ª–æ–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å {session_id}")
                
                response = streaming_pb2.StreamResponse(
                    error_message="–ì–ª–æ–±–∞–ª—å–Ω–æ–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ"
                )
                yield response
                return
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ gRPC Service Manager
            logger.info(f"üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —á–µ—Ä–µ–∑ –º–æ–¥—É–ª–∏...")
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            request_data = {
                'hardware_id': hardware_id,
                'text': request.prompt,
                'screenshot': request.screenshot,
                'session_id': session_id,
                'interrupt_flag': False  # –í –Ω–æ–≤–æ–º protobuf –Ω–µ—Ç interrupt_flag –≤ StreamRequest
            }
            logger.info(f"üîÑ Request data –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω: text='{request.prompt[:50]}...', screenshot_exists={bool(request.screenshot)}")
            
            # –ü–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞: –ø–µ—Ä–µ–¥–∞—ë–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ –º–µ—Ä–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
            sent_any = False
            logger.info(f"üîÑ –ù–∞—á–∏–Ω–∞–µ–º –ø–æ—Ç–æ–∫–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–ª—è {session_id}")
            async for item in self.grpc_service_manager.process(request_data):
                logger.info(f"üîÑ –ü–æ–ª—É—á–µ–Ω item –æ—Ç grpc_service_manager: {list(item.keys())}")
                success = item.get('success', False)
                if not success:
                    err = item.get('error') or '–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞'
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ {session_id}: {err}")
                    yield streaming_pb2.StreamResponse(error_message=err)
                    return
                # –¢–µ–∫—Å—Ç
                txt = item.get('text_response')
                if txt:
                    logger.info(f"‚Üí StreamAudio: sending text_chunk len={len(txt)} for session={session_id}")
                    yield streaming_pb2.StreamResponse(text_chunk=txt)
                    sent_any = True
                # –û–¥–∏–Ω–æ—á–Ω—ã–π –∞—É–¥–∏–æ-—á–∞–Ω–∫
                ch = item.get('audio_chunk')
                if isinstance(ch, (bytes, bytearray)) and len(ch) > 0:
                    logger.info(f"‚Üí StreamAudio: sending audio_chunk bytes={len(ch)} for session={session_id}")
                    yield streaming_pb2.StreamResponse(
                        audio_chunk=streaming_pb2.AudioChunk(audio_data=ch, dtype='int16', shape=[])
                    )
                    sent_any = True
                # –°–ø–∏—Å–æ–∫ –∞—É–¥–∏–æ-—á–∞–Ω–∫–æ–≤ (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤–µ—Ä–Ω—ë—Ç –º–∞—Å—Å–∏–≤)
                for idx, chunk_data in enumerate(item.get('audio_chunks') or []):
                    if chunk_data:
                        logger.info(f"‚Üí StreamAudio: sending audio_chunk[{idx}] bytes={len(chunk_data)} for session={session_id}")
                        yield streaming_pb2.StreamResponse(
                            audio_chunk=streaming_pb2.AudioChunk(audio_data=chunk_data, dtype='int16', shape=[])
                        )
                        sent_any = True
            # –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å—Ç—Ä–∏–º–∞
            logger.info(f"‚Üí StreamAudio: end_message for session={session_id} (sent_any={sent_any})")
            yield streaming_pb2.StreamResponse(end_message="–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
        except Exception as e:
            logger.error(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ StreamRequest: {e}")
            import traceback
            traceback.print_exc()
            
            # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤ –º–µ—Ç—Ä–∏–∫–∏
            record_request(time.time() - start_time, is_error=True)
            
            response = streaming_pb2.StreamResponse(
                error_message=f"–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}"
            )
            yield response
        finally:
            # –£–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            current_connections = get_metrics().get('active_connections', 0)
            set_active_connections(max(0, current_connections - 1))
            
            # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫—É –∑–∞–ø—Ä–æ—Å–∞
            response_time = time.time() - start_time
            record_request(response_time, is_error=False)

    async def GenerateWelcomeAudio(self, request: streaming_pb2.WelcomeRequest, context) -> AsyncGenerator[streaming_pb2.WelcomeResponse, None]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ AudioProcessor"""
        start_time = time.time()
        session_id = request.session_id or f"welcome_{datetime.now().timestamp()}"
        text = (request.text or "").strip()

        if not text:
            logger.error("‚ùå GenerateWelcomeAudio: –ø—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è")
            record_request(0.0, is_error=True)
            yield streaming_pb2.WelcomeResponse(error_message="Empty welcome text")
            return

        logger.info(
            "üì® GenerateWelcomeAudio: session=%s, text_len=%s, voice=%s, language=%s",
            session_id,
            len(text),
            request.voice or "default",
            request.language or "default",
        )

        try:
            if not self.is_initialized:
                init_ok = await self.initialize()
                if not init_ok:
                    logger.error("‚ùå GenerateWelcomeAudio: failed to initialize server modules")
                    record_request(time.time() - start_time, is_error=True)
                    yield streaming_pb2.WelcomeResponse(error_message="Server is not initialized")
                    return

            audio_processor = self.grpc_service_manager.modules.get('audio_generation') if self.grpc_service_manager else None
            if not audio_processor:
                logger.error("‚ùå GenerateWelcomeAudio: audio_generation module not available")
                record_request(time.time() - start_time, is_error=True)
                yield streaming_pb2.WelcomeResponse(error_message="Audio processor unavailable")
                return

            if not getattr(audio_processor, 'is_initialized', False):
                logger.info("üîÑ GenerateWelcomeAudio: initializing audio processor on demand")
                if hasattr(audio_processor, 'initialize'):
                    init_ok = await audio_processor.initialize()
                    if not init_ok:
                        record_request(time.time() - start_time, is_error=True)
                        yield streaming_pb2.WelcomeResponse(error_message="Failed to initialize audio processor")
                        return

            audio_info = {}
            if hasattr(audio_processor, 'get_audio_info'):
                try:
                    audio_info = audio_processor.get_audio_info() or {}
                except Exception as info_err:
                    logger.warning(f"‚ö†Ô∏è GenerateWelcomeAudio: failed to get audio info: {info_err}")

            sample_rate = int(audio_info.get('sample_rate') or 48000)
            channels = int(audio_info.get('channels') or 1)
            dtype = 'int16'
            bytes_per_sample = max(1, int(audio_info.get('bits_per_sample') or 16) // 8)
            bytes_per_frame = bytes_per_sample * max(1, channels)

            total_bytes = 0

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—É–¥–∏–æ —á–∞–Ω–∫–∏
            logger.info("üéµ GenerateWelcomeAudio: start streaming TTS")
            generator = None
            if hasattr(audio_processor, 'generate_speech_streaming'):
                logger.info("üîç GenerateWelcomeAudio: using generate_speech_streaming")
                generator = audio_processor.generate_speech_streaming(text)
            elif hasattr(audio_processor, 'generate_speech'):
                logger.info("üîç GenerateWelcomeAudio: using generate_speech")
                generator = audio_processor.generate_speech(text)

            if generator is None:
                logger.error("‚ùå GenerateWelcomeAudio: audio processor does not provide streaming interface")
                yield streaming_pb2.WelcomeResponse(error_message="Audio processor streaming not available")
                return
            
            logger.info(f"üîç GenerateWelcomeAudio: generator created, type={type(generator)}")

            async for chunk in generator:
                logger.info(f"üîç GenerateWelcomeAudio: received chunk type={type(chunk)}, len={len(chunk) if chunk else 0}")
                if not chunk:
                    logger.warning("‚ö†Ô∏è GenerateWelcomeAudio: empty chunk received, skipping")
                    continue
                chunk_bytes = bytes(chunk)
                logger.info(f"üîç GenerateWelcomeAudio: chunk_bytes len={len(chunk_bytes)}")
                total_bytes += len(chunk_bytes)
                yield streaming_pb2.WelcomeResponse(
                    audio_chunk=streaming_pb2.AudioChunk(
                        audio_data=chunk_bytes,
                        dtype=dtype,
                        shape=[],
                    )
                )

            duration_sec = 0.0
            if total_bytes and bytes_per_frame:
                duration_sec = total_bytes / (bytes_per_frame * float(sample_rate))

            metadata = streaming_pb2.WelcomeMetadata(
                method="server",
                duration_sec=duration_sec,
                sample_rate=sample_rate,
                channels=channels,
            )
            yield streaming_pb2.WelcomeResponse(metadata=metadata)
            yield streaming_pb2.WelcomeResponse(end_message="Welcome audio generation completed")

            response_time = time.time() - start_time
            record_request(response_time, is_error=False)

        except Exception as e:
            logger.error(f"‚ùå GenerateWelcomeAudio: –æ—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è: {e}")
            import traceback
            traceback.print_exc()
            record_request(time.time() - start_time, is_error=True)
            yield streaming_pb2.WelcomeResponse(error_message=f"Failed to generate welcome audio: {e}")


    async def InterruptSession(self, request: streaming_pb2.InterruptRequest, context) -> streaming_pb2.InterruptResponse:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ InterruptRequest —á–µ—Ä–µ–∑ Interrupt Manager"""
        hardware_id = request.hardware_id or "unknown"
        # –í InterruptRequest –Ω–µ—Ç session_id, —Ç–æ–ª—å–∫–æ hardware_id
        
        logger.info(f"üõë –ü–æ–ª—É—á–µ–Ω InterruptRequest: hardware_id={hardware_id}")
        
        try:
            if not self.interrupt_manager:
                logger.error("Interrupt Manager –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ")
                return streaming_pb2.InterruptResponse(
                    success=False,
                    message="Interrupt manager unavailable",
                    interrupted_sessions=[]
                )

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Interrupt Manager –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            interrupt_result = await self.interrupt_manager.interrupt_session(
                hardware_id=hardware_id
            )
            
            if interrupt_result.get('success', False):
                logger.info(f"‚úÖ –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –¥–ª—è {hardware_id}")
                
                return streaming_pb2.InterruptResponse(
                    success=True,
                    message="–°–µ—Å—Å–∏–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–µ—Ä–≤–∞–Ω—ã",
                    interrupted_sessions=interrupt_result.get('cleaned_sessions', [])
                )
            else:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –¥–ª—è {hardware_id}")
                
                return streaming_pb2.InterruptResponse(
                    success=False,
                    message=interrupt_result.get('message', '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ—Ä–≤–∞—Ç—å —Å–µ—Å—Å–∏–∏'),
                    interrupted_sessions=[]
                )
        
        except Exception as e:
            logger.error(f"üí• –û—à–∏–±–∫–∞ –≤ InterruptRequest: {e}")
            import traceback
            traceback.print_exc()
            
            return streaming_pb2.InterruptResponse(
                success=False,
                message=f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è: {str(e)}",
                interrupted_sessions=[]
            )

async def run_server(port: int = 50051, max_workers: int = 100):
    """–ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ gRPC —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è 100 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    logger.info(f"üöÄ –ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ gRPC —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É {port} —Å {max_workers} –≤–æ—Ä–∫–µ—Ä–∞–º–∏")
    
    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π ThreadPoolExecutor
    executor = ThreadPoolExecutor(
        max_workers=max_workers,
        thread_name_prefix="grpc-worker"
    )
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –≤—ã—Å–æ–∫–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏
    options = [
        # Keep-alive –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        ('grpc.keepalive_time_ms', 30000),
        ('grpc.keepalive_timeout_ms', 5000),
        ('grpc.keepalive_permit_without_calls', True),
        
        # HTTP/2 –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        ('grpc.http2.max_pings_without_data', 0),
        ('grpc.http2.min_time_between_pings_ms', 10000),
        ('grpc.http2.min_ping_interval_without_data_ms', 300000),
        
        # –ë—É—Ñ–µ—Ä—ã
        ('grpc.max_receive_message_length', 4 * 1024 * 1024),  # 4MB
        ('grpc.max_send_message_length', 4 * 1024 * 1024),     # 4MB
        
        # –¢–∞–π–º–∞—É—Ç—ã
        ('grpc.client_idle_timeout_ms', 300000),  # 5 –º–∏–Ω—É—Ç
    ]
    
    # –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–≤–µ—Ä —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
    server = grpc.aio.server(executor, options=options)
    
    # –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–≤–∏—Å
    servicer = NewStreamingServicer()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å
    init_success = await servicer.initialize()
    if not init_success:
        logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å")
        return False
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ä–≤–∏—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    streaming_pb2_grpc.add_StreamingServiceServicer_to_server(servicer, server)
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–æ—Ä—Ç
    listen_addr = f'[::]:{port}'
    server.add_insecure_port(listen_addr)
    
    logger.info(f"‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ {listen_addr}")
    logger.info(f"üìä –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:")
    logger.info(f"   - –í–æ—Ä–∫–µ—Ä—ã: {max_workers}")
    logger.info(f"   - Keep-alive: 30s")
    logger.info(f"   - –ë—É—Ñ–µ—Ä—ã: 4MB")
    logger.info(f"   - –¢–∞–π–º–∞—É—Ç –∫–ª–∏–µ–Ω—Ç–∞: 5 –º–∏–Ω—É—Ç")
    
    try:
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä
        await server.start()
        logger.info(f"üéâ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π gRPC —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {port}")
        
        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        await server.wait_for_termination()
        
    except KeyboardInterrupt:
        logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è")
    except Exception as e:
        logger.error(f"üí• –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
    finally:
        # –û—á–∏—â–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã
        logger.info("üßπ –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...")
        await servicer.cleanup()
        
        # Graceful shutdown
        await server.stop(grace=5.0)
        logger.info("‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    try:
        await run_server()
    except Exception as e:
        logger.error(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
