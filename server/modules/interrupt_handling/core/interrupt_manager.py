"""
–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä Interrupt Handling Module

–£–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è–º–∏, –≥–ª–æ–±–∞–ª—å–Ω—ã–º–∏ —Ñ–ª–∞–≥–∞–º–∏ –∏ –æ—Ç–º–µ–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–π
"""

import asyncio
import logging
import time
import sys
import os
from typing import Dict, Any, Optional, Set, Callable
from datetime import datetime

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –∫–æ—Ä–Ω–µ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å–µ—Ä–≤–µ—Ä–∞
sys.path.append(os.path.join(os.path.dirname(__file__), '../../../../'))

from integrations.core.universal_module_interface import UniversalModuleInterface, ModuleStatus
from modules.interrupt_handling.config import InterruptHandlingConfig

logger = logging.getLogger(__name__)

class InterruptManager(UniversalModuleInterface):
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
    
    –£–ø—Ä–∞–≤–ª—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–º–∏ —Ñ–ª–∞–≥–∞–º–∏, –∞–∫—Ç–∏–≤–Ω—ã–º–∏ —Å–µ—Å—Å–∏—è–º–∏ –∏ –æ—Ç–º–µ–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–π
    """
    
    def __init__(self, config: Optional[InterruptHandlingConfig] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
        
        Args:
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
        """
        super().__init__("interrupt_handling", config.config if config else {})
        
        self.config = config or InterruptHandlingConfig()
        
        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        self.global_interrupt_flag = False
        self.interrupt_hardware_id: Optional[str] = None
        self.interrupt_timestamp: Optional[float] = None
        
        # –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
        self.session_counter = 0
        
        # –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏ –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        self.registered_modules: Dict[str, Any] = {}
        
        # Callback —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        self.interrupt_callbacks: Set[Callable] = set()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.total_interrupts = 0
        self.successful_interrupts = 0
        self.failed_interrupts = 0
        
        logger.info("Interrupt Manager created")
    
    async def initialize(self) -> bool:
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
        
        Returns:
            True –µ—Å–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            logger.info("Initializing Interrupt Manager...")
            
            self.set_status(ModuleStatus.INITIALIZING)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
            if not self.config.get("global_interrupt_enabled", True):
                logger.warning("Global interrupt is disabled in configuration")
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            await self._initialize_components()
            
            self.set_status(ModuleStatus.READY)
            self.is_initialized = True
            
            logger.info("Interrupt Manager initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize Interrupt Manager: {e}")
            self.set_status(ModuleStatus.ERROR)
            return False
    
    async def _initialize_components(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            from modules.interrupt_handling.providers.global_flag_provider import GlobalFlagProvider
            from modules.interrupt_handling.providers.session_tracker_provider import SessionTrackerProvider
            
            self.global_flag_provider = GlobalFlagProvider(self.config)
            self.session_tracker_provider = SessionTrackerProvider(self.config)
            
            await self.global_flag_provider.initialize()
            await self.session_tracker_provider.initialize()
            
            logger.info("Interrupt providers initialized")
            
        except Exception as e:
            logger.error(f"Failed to initialize interrupt providers: {e}")
            raise
    
    async def process(self, input_data: Dict[str, Any]) -> Any:
        """
        –û—Å–Ω–æ–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
        
        Args:
            input_data: –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            
        Returns:
            –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        """
        try:
            operation = input_data.get("operation", "interrupt_session")
            
            if operation == "interrupt_session":
                return await self.interrupt_session(input_data.get("hardware_id", ""))
            elif operation == "register_module":
                return await self.register_module(
                    input_data.get("module_name", ""),
                    input_data.get("module_instance")
                )
            elif operation == "register_callback":
                return await self.register_callback(input_data.get("callback"))
            elif operation == "check_interrupt":
                return self.should_interrupt(input_data.get("hardware_id", ""))
            else:
                logger.warning(f"Unknown interrupt operation: {operation}")
                return {"success": False, "error": f"Unknown operation: {operation}"}
                
        except Exception as e:
            logger.error(f"Error processing interrupt request: {e}")
            return {"success": False, "error": str(e)}
    
    async def interrupt_session(self, hardware_id: str) -> Dict[str, Any]:
        """
        –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ hardware_id
        
        Args:
            hardware_id: ID –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            
        Returns:
            –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        """
        try:
            interrupt_start_time = time.time()
            
            logger.warning(f"üö® Interrupt session requested for hardware_id: {hardware_id}")
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏
            await self._set_global_interrupt_flags(hardware_id)
            
            # –ü—Ä–µ—Ä—ã–≤–∞–µ–º –≤—Å–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏
            interrupted_modules = await self._interrupt_all_modules(hardware_id)
            
            # –û—á–∏—â–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏
            cleaned_sessions = await self._cleanup_sessions(hardware_id)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.total_interrupts += 1
            self.successful_interrupts += 1
            
            interrupt_end_time = time.time()
            total_time = (interrupt_end_time - interrupt_start_time) * 1000
            
            logger.warning(f"‚úÖ Interrupt completed for {hardware_id} in {total_time:.1f}ms")
            
            return {
                "success": True,
                "hardware_id": hardware_id,
                "interrupted_modules": interrupted_modules,
                "cleaned_sessions": cleaned_sessions,
                "total_time_ms": total_time,
                "timestamp": interrupt_start_time
            }
            
        except Exception as e:
            logger.error(f"Error interrupting session for {hardware_id}: {e}")
            self.failed_interrupts += 1
            
            return {
                "success": False,
                "hardware_id": hardware_id,
                "error": str(e),
                "timestamp": time.time()
            }
    
    async def _set_global_interrupt_flags(self, hardware_id: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Ñ–ª–∞–≥–æ–≤ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è"""
        try:
            self.global_interrupt_flag = True
            self.interrupt_hardware_id = hardware_id
            self.interrupt_timestamp = time.time()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Ñ–ª–∞–≥–æ–≤
            if hasattr(self, 'global_flag_provider'):
                await self.global_flag_provider.set_interrupt_flag(hardware_id)
            
            logger.warning(f"üö® Global interrupt flags set for {hardware_id}")
            
        except Exception as e:
            logger.error(f"Error setting global interrupt flags: {e}")
            raise
    
    async def _interrupt_all_modules(self, hardware_id: str) -> list:
        """–ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π"""
        interrupted_modules = []
        
        try:
            for module_name, module_instance in self.registered_modules.items():
                try:
                    if not self.config.is_module_interrupt_enabled(module_name):
                        logger.debug(f"Interrupt disabled for module: {module_name}")
                        continue
                    
                    # –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–æ–¥—ã –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –¥–ª—è –º–æ–¥—É–ª—è
                    interrupt_methods = self.config.get_module_interrupt_methods(module_name)
                    module_timeout = self.config.get_module_timeout(module_name)
                    
                    # –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥—ã –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
                    for method_name in interrupt_methods:
                        if hasattr(module_instance, method_name):
                            method = getattr(module_instance, method_name)
                            
                            # –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                            try:
                                if asyncio.iscoroutinefunction(method):
                                    await asyncio.wait_for(method(), timeout=module_timeout)
                                else:
                                    method()
                                
                                logger.warning(f"üö® Module {module_name}.{method_name} interrupted for {hardware_id}")
                                
                            except asyncio.TimeoutError:
                                logger.error(f"Timeout interrupting {module_name}.{method_name}")
                            except Exception as e:
                                logger.error(f"Error interrupting {module_name}.{method_name}: {e}")
                    
                    interrupted_modules.append(module_name)
                    
                except Exception as e:
                    logger.error(f"Error interrupting module {module_name}: {e}")
            
            # –í—ã–∑—ã–≤–∞–µ–º callback —Ñ—É–Ω–∫—Ü–∏–∏
            for callback in self.interrupt_callbacks:
                try:
                    if asyncio.iscoroutinefunction(callback):
                        await callback(hardware_id)
                    else:
                        callback(hardware_id)
                except Exception as e:
                    logger.error(f"Error in interrupt callback: {e}")
            
            logger.info(f"Interrupted {len(interrupted_modules)} modules for {hardware_id}")
            
        except Exception as e:
            logger.error(f"Error interrupting modules: {e}")
        
        return interrupted_modules
    
    async def _cleanup_sessions(self, hardware_id: str) -> list:
        """–û—á–∏—Å—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è hardware_id"""
        cleaned_sessions = []
        
        try:
            sessions_to_remove = []
            
            for session_id, session_data in self.active_sessions.items():
                if session_data.get("hardware_id") == hardware_id:
                    sessions_to_remove.append(session_id)
                    cleaned_sessions.append(session_id)
            
            # –£–¥–∞–ª—è–µ–º —Å–µ—Å—Å–∏–∏
            for session_id in sessions_to_remove:
                del self.active_sessions[session_id]
            
            logger.info(f"Cleaned {len(cleaned_sessions)} sessions for {hardware_id}")
            
        except Exception as e:
            logger.error(f"Error cleaning up sessions: {e}")
        
        return cleaned_sessions
    
    async def register_module(self, module_name: str, module_instance: Any) -> bool:
        """
        –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        
        Args:
            module_name: –ò–º—è –º–æ–¥—É–ª—è
            module_instance: –≠–∫–∑–µ–º–ø–ª—è—Ä –º–æ–¥—É–ª—è
            
        Returns:
            True –µ—Å–ª–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            self.registered_modules[module_name] = module_instance
            logger.info(f"Module {module_name} registered for interrupt handling")
            return True
            
        except Exception as e:
            logger.error(f"Error registering module {module_name}: {e}")
            return False
    
    async def register_callback(self, callback: Callable) -> bool:
        """
        –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è callback —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        
        Args:
            callback: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
            
        Returns:
            True –µ—Å–ª–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            self.interrupt_callbacks.add(callback)
            logger.info("Callback registered for interrupt handling")
            return True
            
        except Exception as e:
            logger.error(f"Error registering callback: {e}")
            return False
    
    def should_interrupt(self, hardware_id: str) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ hardware_id
        
        Args:
            hardware_id: ID –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è
            
        Returns:
            True –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å, False –∏–Ω–∞—á–µ
        """
        if not self.global_interrupt_flag:
            return False
        
        if self.interrupt_hardware_id != hardware_id:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
        if self.interrupt_timestamp:
            current_time = time.time()
            interrupt_timeout = self.config.get("interrupt_timeout", 5.0)
            
            if current_time - self.interrupt_timestamp > interrupt_timeout:
                logger.warning(f"Interrupt timeout for {hardware_id}, resetting flags")
                self._reset_interrupt_flags()
                return False
        
        return True
    
    def _reset_interrupt_flags(self):
        """–°–±—Ä–æ—Å –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Ñ–ª–∞–≥–æ–≤ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è"""
        self.global_interrupt_flag = False
        self.interrupt_hardware_id = None
        self.interrupt_timestamp = None
        
        logger.info("Global interrupt flags reset")
    
    def register_session(self, session_id: str, hardware_id: str, session_data: Dict[str, Any]) -> bool:
        """
        –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏
        
        Args:
            session_id: ID —Å–µ—Å—Å–∏–∏
            hardware_id: ID –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è
            session_data: –î–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏
            
        Returns:
            True –µ—Å–ª–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            self.active_sessions[session_id] = {
                "hardware_id": hardware_id,
                "start_time": time.time(),
                "data": session_data
            }
            
            self.session_counter += 1
            
            logger.debug(f"Session {session_id} registered for hardware_id: {hardware_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error registering session {session_id}: {e}")
            return False
    
    def unregister_session(self, session_id: str) -> bool:
        """
        –û—Ç–º–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–µ—Å—Å–∏–∏
        
        Args:
            session_id: ID —Å–µ—Å—Å–∏–∏
            
        Returns:
            True –µ—Å–ª–∏ –æ—Ç–º–µ–Ω–∞ —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            if session_id in self.active_sessions:
                del self.active_sessions[session_id]
                logger.debug(f"Session {session_id} unregistered")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error unregistering session {session_id}: {e}")
            return False
    
    async def cleanup(self) -> bool:
        """
        –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –º–æ–¥—É–ª—è
        
        Returns:
            True –µ—Å–ª–∏ –æ—á–∏—Å—Ç–∫–∞ —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            logger.info("Cleaning up Interrupt Manager...")
            
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏
            self._reset_interrupt_flags()
            
            # –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏–∏
            self.active_sessions.clear()
            
            # –û—á–∏—â–∞–µ–º –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏
            self.registered_modules.clear()
            
            # –û—á–∏—â–∞–µ–º callback —Ñ—É–Ω–∫—Ü–∏–∏
            self.interrupt_callbacks.clear()
            
            # –û—á–∏—â–∞–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã
            if hasattr(self, 'global_flag_provider'):
                await self.global_flag_provider.cleanup()
            if hasattr(self, 'session_tracker_provider'):
                await self.session_tracker_provider.cleanup()
            
            self.set_status(ModuleStatus.STOPPED)
            self.is_initialized = False
            
            logger.info("Interrupt Manager cleaned up successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error cleaning up Interrupt Manager: {e}")
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π"""
        return {
            "total_interrupts": self.total_interrupts,
            "successful_interrupts": self.successful_interrupts,
            "failed_interrupts": self.failed_interrupts,
            "success_rate": (
                self.successful_interrupts / self.total_interrupts 
                if self.total_interrupts > 0 else 0
            ),
            "active_sessions": len(self.active_sessions),
            "registered_modules": len(self.registered_modules),
            "registered_callbacks": len(self.interrupt_callbacks),
            "global_interrupt_flag": self.global_interrupt_flag,
            "interrupt_hardware_id": self.interrupt_hardware_id
        }
