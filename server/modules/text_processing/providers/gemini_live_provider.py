"""
Gemini Live Provider –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ Google Search

–ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –ø–æ—ç—Ç–∞–ø–Ω—ã–º –ø–æ–¥—Ö–æ–¥–æ–º:
- –≠—Ç–∞–ø 1: –ë–∞–∑–æ–≤—ã–π Live API (—Ç–µ–∫—Å—Ç ‚Üí —Ç–µ–∫—Å—Ç)
- –≠—Ç–∞–ø 2: JPEG –ø–æ–¥–¥–µ—Ä–∂–∫–∞ (—Ç–µ–∫—Å—Ç + –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Üí —Ç–µ–∫—Å—Ç)  
- –≠—Ç–∞–ø 3: Google Search (—Ç–µ–∫—Å—Ç + –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ + –ø–æ–∏—Å–∫ ‚Üí —Ç–µ–∫—Å—Ç)
"""

import asyncio
import logging
import base64
from typing import AsyncGenerator, Dict, Any, Optional
from integrations.core.universal_provider_interface import UniversalProviderInterface

logger = logging.getLogger(__name__)

# –ò–º–ø–æ—Ä—Ç—ã Gemini Live API (—Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è)
try:
    from google import genai
    from google.genai import types
    GEMINI_LIVE_AVAILABLE = True
except ImportError:
    genai = None
    types = None
    GEMINI_LIVE_AVAILABLE = False
    logger.warning("‚ö†Ô∏è Gemini Live API –Ω–µ –Ω–∞–π–¥–µ–Ω - –ø—Ä–æ–≤–∞–π–¥–µ—Ä –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

class GeminiLiveProvider(UniversalProviderInterface):
    """
    –ü—Ä–æ–≤–∞–π–¥–µ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Gemini Live API
    
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç:
    - –ë–∞–∑–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç–µ–∫—Å—Ç–∞
    - JPEG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    - Google Search
    - –°—Ç—Ä–∏–º–∏–Ω–≥ –æ—Ç–≤–µ—Ç–æ–≤
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Gemini Live –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        
        Args:
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        """
        super().__init__(
            name="gemini_live",
            priority=1,  # –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä
            config=config
        )
        
        self.model_name = config.get('model', 'gemini-live-2.5-flash-preview')
        self.temperature = config.get('temperature', 0.7)
        self.max_tokens = config.get('max_tokens', 2048)
        self.media_resolution = config.get('media_resolution', 'MEDIA_RESOLUTION_HIGH')
        self.tools = config.get('tools', [])
        self.system_prompt = config.get('system_prompt', '')
        self.api_key = config.get('api_key', '')
        
        # JPEG –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        self.image_mime_type = config.get('image_mime_type', 'image/jpeg')
        self.image_max_size = config.get('image_max_size', 10 * 1024 * 1024)
        self.streaming_chunk_size = config.get('streaming_chunk_size', 8192)
        
        # –ö–ª–∏–µ–Ω—Ç
        self.client = None
        self.is_available = GEMINI_LIVE_AVAILABLE and bool(self.api_key)
        self.is_initialized = False
        
        logger.info(f"GeminiLiveProvider initialized: available={self.is_available}")
    
    async def initialize(self) -> bool:
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Live API
        
        Returns:
            True –µ—Å–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            logger.info(f"üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê GeminiLiveProvider.initialize():")
            logger.info(f"   ‚Üí is_available: {self.is_available}")
            logger.info(f"   ‚Üí api_key present: {bool(self.api_key)}")
            logger.info(f"   ‚Üí model_name: {self.model_name}")
            
            if not self.is_available:
                logger.error("Missing API key or dependencies")
                return False
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç
            logger.info(f"üîç –°–æ–∑–¥–∞–µ–º Gemini –∫–ª–∏–µ–Ω—Ç...")
            self.client = genai.Client(api_key=self.api_key)
            logger.info(f"‚úÖ Gemini –∫–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω")
            
            # –ë–∞–∑–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
            config = {
                "response_modalities": ["TEXT"]
            }
            # –î–æ–±–∞–≤–ª—è–µ–º system_instruction –µ—Å–ª–∏ –∑–∞–¥–∞–Ω
            if self.system_prompt:
                logger.info(f"üîç System prompt: '{self.system_prompt[:100]}...'")
                try:
                    # –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω types.Content, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ —Å—Ç—Ä–æ–∫—É
                    if types and hasattr(types, 'Content') and hasattr(types, 'Part'):
                        config["system_instruction"] = types.Content(
                            parts=[types.Part.from_text(text=self.system_prompt)],
                            role="user"
                        )
                        logger.info(f"‚úÖ System instruction –¥–æ–±–∞–≤–ª–µ–Ω —Å role='user'")
                    else:
                        config["system_instruction"] = self.system_prompt
                        logger.info(f"‚úÖ System instruction –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ —Å—Ç—Ä–æ–∫–∞")
                except Exception:
                    config["system_instruction"] = self.system_prompt
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –µ—Å–ª–∏ –µ—Å—Ç—å (Google Search –¥–ª—è —ç—Ç–∞–ø–∞ 3)
            if self.tools and "google_search" in self.tools:
                config["tools"] = [{"google_search": {}}]
            
            # –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º media_resolution - –º–æ–¥–µ–ª—å –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
            logger.info(f"üîç –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Gemini Live API...")
            async with self.client.aio.live.connect(model=self.model_name, config=config) as test_session:
                logger.info(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Gemini Live API —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
                
                logger.info(f"üîç –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...")
                await test_session.send_client_content(
                    turns={"role": "user", "parts": [{"text": "Hello"}]}, 
                    turn_complete=True
                )
                logger.info(f"‚úÖ –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
                
                logger.info(f"üîç –û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç Gemini...")
                async for response in test_session.receive():
                    logger.info(f"üîç –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç: {type(response)}")
                    if response.text:
                        self.is_initialized = True
                        logger.info(f"‚úÖ Live API initialized: {self.model_name}")
                        return True
            
            logger.error(f"‚ùå –¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ –æ—Ç–≤–µ—Ç")
            return False
            
        except Exception as e:
            logger.error(f"Live API initialization failed: {e}")
            return False
    
    async def process(self, input_data: str) -> AsyncGenerator[str, None]:
        """
        –≠–¢–ê–ü 1: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ —á–µ—Ä–µ–∑ Live API
        
        Args:
            input_data: –¢–µ–∫—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
            
        Yields:
            –ß–∞—Å—Ç–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        """
        try:
            if not self.is_initialized or not self.client:
                raise Exception("Live API not initialized")
            
            # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
            config = {
                "response_modalities": ["TEXT"]
            }
            if self.system_prompt:
                try:
                    if types and hasattr(types, 'Content') and hasattr(types, 'Part'):
                        config["system_instruction"] = types.Content(
                            parts=[types.Part.from_text(text=self.system_prompt)],
                            role="user"
                        )
                    else:
                        config["system_instruction"] = self.system_prompt
                except Exception:
                    config["system_instruction"] = self.system_prompt
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –µ—Å–ª–∏ –µ—Å—Ç—å (Google Search –¥–ª—è —ç—Ç–∞–ø–∞ 3)
            if self.tools and "google_search" in self.tools:
                config["tools"] = [{"google_search": {}}]
            
            async with self.client.aio.live.connect(model=self.model_name, config=config) as session:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
                await session.send_client_content(
                    turns={"role": "user", "parts": [{"text": input_data}]}, 
                    turn_complete=True
                )
                
                # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç
                async for response in session.receive():
                    if response.text:
                        # –ù–ï —Ä–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∑–¥–µ—Å—å - —ç—Ç–æ –¥–µ–ª–∞–µ—Ç StreamingWorkflowIntegration
                        yield response.text
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã (Google Search) - –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞—Ç—Ä–∏–±—É—Ç–∞
                    if hasattr(response, 'tool_calls') and response.tool_calls:
                        for tool_call in response.tool_calls:
                            if hasattr(tool_call, 'google_search') and tool_call.google_search:
                                logger.info("Google Search executed")
                    
                    if response.server_content and response.server_content.turn_complete:
                        break
                
                logger.debug("Live API text processing completed")
                
        except Exception as e:
            logger.error(f"Live API text processing error: {e}")
            raise e
    
    async def process_with_image(self, input_data: str, image_data: bytes) -> AsyncGenerator[str, None]:
        """
        –≠–¢–ê–ü 2: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ —Å JPEG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
        
        Args:
            input_data: –¢–µ–∫—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
            image_data: JPEG –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            
        Yields:
            –ß–∞—Å—Ç–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        """
        try:
            if not self.is_initialized or not self.client:
                raise Exception("Live API not initialized")
            
            # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (–±–µ–∑ media_resolution)
            config = {
                "response_modalities": ["TEXT"]
            }
            if self.system_prompt:
                try:
                    if types and hasattr(types, 'Content') and hasattr(types, 'Part'):
                        config["system_instruction"] = types.Content(
                            parts=[types.Part.from_text(text=self.system_prompt)],
                            role="user"
                        )
                    else:
                        config["system_instruction"] = self.system_prompt
                except Exception:
                    config["system_instruction"] = self.system_prompt
            
            # –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º media_resolution - –º–æ–¥–µ–ª—å –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –µ—Å–ª–∏ –µ—Å—Ç—å (Google Search –¥–ª—è —ç—Ç–∞–ø–∞ 3)
            if self.tools and "google_search" in self.tools:
                config["tools"] = [{"google_search": {}}]
            
            async with self.client.aio.live.connect(model=self.model_name, config=config) as session:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
                await session.send_client_content(
                    turns={"role": "user", "parts": [{"text": input_data}]}, 
                    turn_complete=False
                )
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º JPEG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                await self._send_jpeg_image(session, image_data)
                
                # –ó–∞–≤–µ—Ä—à–∞–µ–º –≤–≤–æ–¥
                await session.send_client_content(turn_complete=True)
                
                # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç
                async for response in session.receive():
                    if response.text:
                        # –ù–ï —Ä–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∑–¥–µ—Å—å - —ç—Ç–æ –¥–µ–ª–∞–µ—Ç StreamingWorkflowIntegration
                        yield response.text
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã (Google Search) - –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞—Ç—Ä–∏–±—É—Ç–∞
                    if hasattr(response, 'tool_calls') and response.tool_calls:
                        for tool_call in response.tool_calls:
                            if hasattr(tool_call, 'google_search') and tool_call.google_search:
                                logger.info("Google Search executed with image")
                    
                    if response.server_content and response.server_content.turn_complete:
                        break
                
                logger.debug("Live API with image processing completed")
                
        except Exception as e:
            logger.error(f"Live API with image processing error: {e}")
            raise e
    
    async def _send_jpeg_image(self, session, image_data: bytes) -> None:
        """
        –û—Ç–ø—Ä–∞–≤–∫–∞ JPEG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ Live API
        
        Args:
            session: Live API —Å–µ—Å—Å–∏—è
            image_data: JPEG –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        """
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ image_data –Ω–µ None
            if image_data is None:
                logger.debug("No image data provided, skipping image processing")
                return
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º JPEG —Ñ–æ—Ä–º–∞—Ç
            if not image_data.startswith(b'\xff\xd8\xff'):
                raise ValueError("Image must be in JPEG format")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä
            if len(image_data) > self.image_max_size:
                raise ValueError(f"Image too large: {len(image_data)} bytes")
            
            # –ö–†–ò–¢–ò–ß–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º send_client_content, –ù–ï send_realtime_input
            image_b64 = base64.b64encode(image_data).decode('utf-8')
            
            await session.send_client_content(
                turns={
                    "role": "user", 
                    "parts": [
                        {
                            "inline_data": {
                                "mime_type": self.image_mime_type,
                                "data": image_b64
                            }
                        }
                    ]
                }, 
                turn_complete=False
            )
            
            logger.debug("JPEG image sent successfully")
            
        except Exception as e:
            logger.error(f"Error sending JPEG image: {e}")
            raise e
    
    def _split_into_sentences(self, text: str) -> list:
        """
        –†–∞–∑–±–∏–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è
            
        Returns:
            –°–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
        """
        if not text:
            return []
        
        import re
        sentences = re.split(r'[.!?]+', text)
        
        result = []
        for sentence in sentences:
            sentence = sentence.strip()
            if sentence:
                if not re.search(r'[.!?]$', sentence):
                    sentence += '.'
                result.append(sentence)
        
        return result
    
    async def cleanup(self) -> bool:
        """
        –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        
        Returns:
            True –µ—Å–ª–∏ –æ—á–∏—Å—Ç–∫–∞ —É—Å–ø–µ—à–Ω–∞, False –∏–Ω–∞—á–µ
        """
        try:
            self.client = None
            self.is_initialized = False
            logger.info("Live API cleaned up")
            return True
        except Exception as e:
            logger.error(f"Error cleaning up Live API: {e}")
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º
        """
        base_status = super().get_status()
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        base_status.update({
            "provider_type": "gemini_live",
            "model_name": self.model_name,
            "temperature": self.temperature,
            "max_tokens": self.max_tokens,
            "tools": self.tools,
            "media_resolution": self.media_resolution,
            "is_available": self.is_available,
            "api_key_set": bool(self.api_key),
            "gemini_live_available": GEMINI_LIVE_AVAILABLE
        })
        
        return base_status
    
    def get_metrics(self) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        """
        base_metrics = super().get_metrics()
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        base_metrics.update({
            "provider_type": "gemini_live",
            "model_name": self.model_name,
            "is_available": self.is_available,
            "api_key_set": bool(self.api_key),
            "tools_enabled": len(self.tools) > 0
        })
        
        return base_metrics